{
  "interviews": [
    {
      "question": "React 컴포넌트가 렌더링되는 과정과 Reconciliation 알고리즘이 어떻게 동작하는지 설명해주세요.",
      "answer": "React는 상태나 props가 변경되면 렌더링 과정을 시작하며, 이전 Virtual DOM과 새로운 Virtual DOM을 비교하여 변경된 부분만 실제 DOM에 반영합니다. 이를 Reconciliation이라고 합니다.\n\n동작 방식:\n1. 상태/props 변화 → 함수 컴포넌트 재실행\n2. 새로운 Virtual DOM 생성\n3. Diff 알고리즘을 통해 이전과 비교\n4. 변경된 노드만 실제 DOM에 Commit\n\nReact의 Diff 알고리즘은 트리를 깊이 우선으로 탐색하며, 형제 노드 비교 시 O(n)으로 최적화되어 있습니다.",
      "category": "react",
      "difficulty": "hard",
      "tags": ["React", "Rendering", "Reconciliation", "Virtual DOM"]
    },
    {
      "question": "React의 상태 업데이트가 비동기적으로 처리되는 이유는 무엇인가요?",
      "answer": "React는 여러 상태 업데이트를 묶어서(batch) 처리함으로써 불필요한 렌더링을 줄이고 성능을 최적화합니다. 이를 위해 상태 업데이트는 동기적으로 즉시 반영되지 않고, 이벤트 루프 또는 React 내부의 업데이트 큐에 의해 비동기적으로 처리됩니다.\n\n주요 이유:\n- 여러 setState 호출을 하나의 렌더링으로 병합\n- 브라우저 렌더링 스케줄링과 React Fiber의 우선순위 조정\n\n결론적으로 상태 업데이트는 성능 최적화를 위한 설계입니다.",
      "category": "react",
      "difficulty": "medium",
      "tags": ["React", "setState", "비동기", "Batching"]
    },
    {
      "question": "useMemo와 useCallback의 차이와 사용 시 주의점을 설명해주세요.",
      "answer": "useMemo는 '값'을, useCallback은 '함수'를 메모이제이션합니다.\n\n차이:\n- useMemo: 계산 비용 큰 값을 캐싱\n- useCallback: 동일한 함수 객체 참조 보장\n\n주의점:\n- 불필요하게 사용하면 오히려 메모리 사용만 증가\n- 의존성 배열 누락 시 stale value 발생\n- 특히 useCallback은 하위 컴포넌트의 props 최적화가 필요할 때만 사용해야 효과가 있음",
      "category": "react",
      "difficulty": "medium",
      "tags": ["React", "Hooks", "useMemo", "useCallback"]
    },
    {
      "question": "React 18의 Concurrent Rendering이 무엇이고, 어떤 방식으로 렌더링을 최적화하는지 설명해주세요.",
      "answer": "Concurrent Rendering은 React 18의 핵심 기능으로, 렌더링 작업을 중단(suspend)하고 우선순위가 높은 작업으로 전환할 수 있게 해줍니다. 이를 통해 UI 응답성이 크게 향상됩니다.\n\n특징:\n- 렌더링을 시간 분할(Time Slicing)하여 작업을 쪼갬\n- 긴 렌더링 작업 중에도 사용자 입력에 빠르게 반응\n- useTransition, Suspense, startTransition 등을 통해 제어 가능\n\n기본적으로 Fiber 아키텍처의 우선순위 기반 스케줄링이 발전된 형태입니다.",
      "category": "react",
      "difficulty": "hard",
      "tags": ["React", "Concurrent Rendering", "React18", "Fiber"]
    },
    {
      "question": "React에서 상태 관리 전략을 어떻게 선택하나요?(local state, context, reducer, external store 등)",
      "answer": "상태 관리 전략은 데이터의 범위와 복잡도에 따라 선택합니다.\n\n선택 기준:\n- 로컬 상태만 필요한 경우: useState\n- 여러 컴포넌트에서 공유: Context + useReducer\n- 비동기 요청 + 전역 상태: Zustand, Redux Toolkit\n- 서버 상태 관리: React Query\n\n핵심은 '상태가 필요한 컴포넌트의 범위'와 '데이터의 변경 빈도' 기반으로 선택하는 것입니다.",
      "category": "react",
      "difficulty": "medium",
      "tags": ["React", "상태관리", "Context", "Redux", "React Query"]
    },

    {
      "question": "TypeScript의 제네릭(Generic)이 필요한 이유와 사용 사례를 설명해주세요.",
      "answer": "제네릭은 타입을 파라미터화하여 재사용성과 타입 안전성을 동시에 확보할 수 있는 기능입니다.\n\n필요 이유:\n- 함수/클래스에서 여러 타입을 유연하게 처리\n- any 사용 시 잃게 되는 타입 추론 능력 유지\n\n사용 사례:\n- API 응답 타입 래핑\n- 유틸리티 함수(ex: Array<T>)\n- React Component의 props 타입 제약\n\n제네릭은 타입 안정성과 재사용성을 크게 향상시키는 핵심 기능입니다.",
      "category": "typescript",
      "difficulty": "medium",
      "tags": ["TypeScript", "Generic", "타입시스템"]
    },
    {
      "question": "TypeScript의 타입 좁히기(Narrowing)가 어떻게 동작하는지 설명해주세요.",
      "answer": "타입 좁히기는 조건문을 통해 넓은 타입을 특정 타입으로 구체화하는 과정입니다.\n\n동작 방식:\n- typeof 검사: number, string 등 원시 타입 좁히기\n- instanceof: 클래스 타입 좁히기\n- in 연산자: 객체 프로퍼티 조건 기반 좁히기\n- 사용자 정의 타입 가드: value is Type 형태로 직접 좁히기\n\n타입 좁히기는 복잡한 유니온 타입을 안전하게 처리하는 핵심 기술입니다.",
      "category": "typescript",
      "difficulty": "medium",
      "tags": ["TypeScript", "Narrowing", "타입가드"]
    },
    {
      "question": "타입 호환성(Type Compatibility)이란 무엇이며, 구조적 타이핑(structural typing)은 어떻게 동작하나요?",
      "answer": "TypeScript는 구조적 타이핑(Structural Type System)을 기반으로 하여 ‘형태가 같으면 같은 타입’으로 간주합니다.\n\n타입 호환성:\n- 객체의 구조(프로퍼티)가 동일하면 호환 가능\n- 명시적 타입 선언보다 구조가 중요\n\n예:\n```ts\ninterface A { x: number }\ninterface B { x: number }\nconst a: A = { x: 1 }\nconst b: B = a // 허용\n```\n\n이는 Java/C#의 Nominal Typing과 비교되는 TS의 중요한 특징입니다.",
      "category": "typescript",
      "difficulty": "hard",
      "tags": ["TypeScript", "타입 호환성", "Structural Typing"]
    },
    {
      "question": "Discriminated Union이 무엇이며, 어떤 상황에서 사용하나요?",
      "answer": "Discriminated Union은 공통된 식별자 프로퍼티(discriminator)를 사용해 유니온 타입을 안전하게 구분하는 방식입니다.\n\n특징:\n- switch-case 기반 타입 좁히기 매우 용이\n- API 응답 타입 모델링에 자주 사용\n\n예:\n```ts\ninterface Loading { type: 'loading' }\ninterface Success { type: 'success'; data: string }\ninterface Error { type: 'error'; message: string }\n\ntype Result = Loading | Success | Error\n```\n\n이를 통해 런타임 에러 없이 안전한 분기 처리가 가능합니다.",
      "category": "typescript",
      "difficulty": "medium",
      "tags": ["TypeScript", "Union", "Discriminated Union"]
    },
    {
      "question": "타입 레벨 프로그래밍(Type-level Programming)이란 무엇이며 어떤 상황에서 사용하나요?",
      "answer": "타입 레벨 프로그래밍은 타입 시스템을 이용해 컴파일 단계에서 로직을 수행하는 프로그래밍 기법입니다.\n\n사용 사례:\n- API 응답 구조 자동 생성\n- 재귀적 타입 구성(DeepReadonly 등)\n- 조건부 타입(Conditional Types)\n- 매핑된 타입(Mapped Types) 조합\n\n예시:\n```ts\ntype Nullable<T> = { [K in keyof T]: T[K] | null }\n```\n타입 레벨 프로그래밍은 대규모 코드베이스의 안정성을 극대화하는 데 중요한 역할을 합니다.",
      "category": "typescript",
      "difficulty": "hard",
      "tags": ["TypeScript", "타입 레벨 프로그래밍", "Conditional Type"]
    }
  ]
}
