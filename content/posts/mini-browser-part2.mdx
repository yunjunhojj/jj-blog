---
title: "나만의 웹 브라우저 만들기 (2부) - 레이아웃 & 페인팅 엔진"
date: 2025-11-04
description: "CSS 박스 모델을 실제로 계산하고 Canvas에 렌더링하는 과정을 구현합니다. Reflow가 왜 비싼 연산인지 체감해보세요."
tags: ["Browser", "CSS", "Canvas", "Layout"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (2부) - 레이아웃 & 페인팅 엔진

> "브라우저는 `margin: 10px; width: 200px;` 같은 CSS를 어떻게 계산해서 화면에 배치할까?"

## 이전 편 복습

[Part 1](/posts/mini-browser-part1)에서 HTML과 CSS를 파싱하여 DOM 트리와 CSS 룰셋을 만들었습니다. 이제 이 데이터를 실제 화면에 그릴 차례입니다!

**오늘의 목표**:

- CSS 박스 모델 완벽 이해
- 레이아웃 엔진 구현 (위치와 크기 계산)
- Canvas API로 실제 렌더링

## CSS 박스 모델의 진실

모든 HTML 요소는 박스입니다. 이 박스는 4개의 영역으로 구성됩니다:

```
┌─────────────────────────┐
│      margin             │ ← 외부 여백
│  ┌───────────────────┐  │
│  │   border          │  │ ← 테두리
│  │ ┌───────────────┐ │  │
│  │ │  padding      │ │  │ ← 내부 여백
│  │ │ ┌───────────┐ │ │  │
│  │ │ │  content  │ │ │  │ ← 실제 내용
│  │ │ └───────────┘ │ │  │
│  │ └───────────────┘ │  │
│  └───────────────────┘  │
└─────────────────────────┘
```

### box-sizing 속성

**content-box (기본값)**:

```typescript
// width = content 영역의 너비
// 실제 요소가 차지하는 공간 = width + padding + border
const totalWidth =
  width + paddingLeft + paddingRight + borderLeft + borderRight;
```

**border-box (실무에서 선호)**:

```typescript
// width = content + padding + border 전체
// 실제 요소가 차지하는 공간 = width
const contentWidth =
  width - paddingLeft - paddingRight - borderLeft - borderRight;
```

### Margin Collapse (마진 병합)

인접한 블록 요소의 수직 마진은 병합됩니다:

```css
.box1 {
  margin-bottom: 20px;
}
.box2 {
  margin-top: 30px;
}
```

실제 간격은 `50px`이 아니라 `max(20px, 30px) = 30px`입니다!

## 레이아웃 엔진 구현

### LayoutBox 구조

```typescript
// packages/core/layout/types.ts
export interface LayoutBox {
  nodeId: number;
  nodeType: "element" | "text";
  tagName?: string;
  textContent?: string;

  // 계산된 스타일
  style: ComputedStyle;

  // 박스 위치와 크기
  x: number; // 화면 상 X 좌표
  y: number; // 화면 상 Y 좌표
  width: number; // border-box 너비
  height: number; // border-box 높이

  // 자식 박스들
  children: LayoutBox[];
}

export interface ComputedStyle {
  // 크기
  width?: string;
  height?: string;

  // shorthand
  margin?: string;
  padding?: string;
  border?: string;

  // 여백
  marginTop?: string;
  marginRight?: string;
  marginBottom?: string;
  marginLeft?: string;

  paddingTop?: string;
  paddingRight?: string;
  paddingBottom?: string;
  paddingLeft?: string;

  // 테두리
  borderWidth?: string;
  borderColor?: string;
  borderStyle?: string;

  // 배경 & 텍스트
  background?: string;
  color?: string;
  fontSize?: string;
  fontWeight?: string;
}
```

### 블록 레이아웃 알고리즘

```typescript
// packages/core/layout/engine.ts
import { ComputedStyle, LayoutBox } from "./types";
import { DOMNode } from "../html/parser";

export function layout(
  dom: DOMNode,
  viewport: { width: number; height: number },
  ctx: CanvasRenderingContext2D
): LayoutBox {
  return layoutBlock(dom, 0, 0, viewport.width, ctx);
}

function layoutBlock(
  node: DOMNode,
  x: number,
  y: number,
  parentWidth: number,
  ctx: CanvasRenderingContext2D
): LayoutBox {
  const style = node.computedStyle || {};

  // 1. 너비 계산
  let width = parentWidth;
  if (style.width) {
    if (style.width.endsWith("px")) {
      width = parsePx(style.width);
    } else if (style.width.endsWith("%")) {
      width = (parentWidth * parsePercent(style.width)) / 100;
    }
  }

  // 2. 여백 계산
  const margin = parseBoxValues(style, "margin");
  const padding = parseBoxValues(style, "padding");
  const border = parseBorderWidth(style.borderWidth || "0");

  // 3. content 영역 너비
  const contentWidth = width - padding.left - padding.right - border * 2;

  // 4. 실제 X, Y 위치 (margin 포함)
  const boxX = x + margin.left;
  const boxY = y + margin.top;

  // 5. 자식 레이아웃
  const children: LayoutBox[] = [];
  let childY = boxY + padding.top + border;

  if (node.children) {
    for (const child of node.children) {
      if (child.type === "element") {
        const childBox = layoutBlock(
          child,
          boxX + padding.left + border,
          childY,
          contentWidth,
          ctx
        );
        children.push(childBox);
        childY += childBox.height + parseMarginBottom(child);
      } else if (child.type === "text") {
        const textBox = layoutText(
          child,
          boxX + padding.left + border,
          childY,
          contentWidth,
          style,
          ctx
        );
        children.push(textBox);
        childY += textBox.height;
      }
    }
  }

  // 6. 높이 계산
  let height = padding.top + padding.bottom + border * 2;
  if (style.height && style.height.endsWith("px")) {
    height += parsePx(style.height);
  } else {
    // 자식 높이 합산
    height += childY - (boxY + padding.top + border);
  }

  return {
    nodeId: node.id || 0,
    nodeType: "element",
    tagName: node.name,
    style,
    x: boxX,
    y: boxY,
    width,
    height,
    children,
  };
}

function layoutText(
  node: DOMNode,
  x: number,
  y: number,
  maxWidth: number,
  parentStyle: ComputedStyle,
  ctx: CanvasRenderingContext2D
): LayoutBox {
  const text = node.text || "";
  const fontSize = parsePx(parentStyle.fontSize || "16px");

  // Canvas로 텍스트 크기 측정
  ctx.font = `${parentStyle.fontWeight || "normal"} ${fontSize}px sans-serif`;
  const metrics = ctx.measureText(text);
  const lineHeight = fontSize * 1.2; // 기본 line-height

  // 텍스트 baseline 위치 계산 (y는 content 영역의 top, baseline은 약간 아래)
  // 일반적으로 baseline은 line-height의 약 80% 지점에 위치
  const baselineOffset = fontSize * 0.8;

  return {
    nodeId: node.id || 0,
    nodeType: "text",
    textContent: text,
    style: parentStyle,
    x,
    y: y + baselineOffset, // 텍스트 baseline 위치
    width: Math.min(metrics.width, maxWidth),
    height: lineHeight,
    children: [],
  };
}

function parseBoxValues(
  style: ComputedStyle,
  prefix: "margin" | "padding"
): { top: number; right: number; bottom: number; left: number } {
  return {
    top: parsePx(style[`${prefix}Top`] || "0"),
    right: parsePx(style[`${prefix}Right`] || "0"),
    bottom: parsePx(style[`${prefix}Bottom`] || "0"),
    left: parsePx(style[`${prefix}Left`] || "0"),
  };
}

export function parsePx(value: string): number {
  return parseFloat(value) || 0;
}

function parsePercent(value: string): number {
  return parseFloat(value) || 0;
}

function parseBorderWidth(value: string): number {
  return parseFloat(value) || 0;
}

function parseMarginBottom(node: DOMNode): number {
  const style = node.computedStyle || {};
  return parsePx(style.marginBottom || "0");
}
```

## Canvas 페인터 구현

### 페인팅 순서

브라우저는 특정 순서로 요소를 그립니다:

1. **Background** (배경색/이미지)
2. **Border** (테두리)
3. **Content** (텍스트/이미지)
4. **Children** (자식 요소들)

```typescript
// packages/core/paint/painter.ts
import { LayoutBox } from "../layout/types";
import { parsePx } from "../layout/engine";

export function paint(
  root: LayoutBox,
  options: {
    ctx: CanvasRenderingContext2D;
    pixelRatio: number;
  }
): void {
  const { ctx, pixelRatio } = options;

  // 이전 스케일링 상태 초기화 (repaint 시 누적 방지)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // HiDPI 대응
  ctx.scale(pixelRatio, pixelRatio);

  // 배경 클리어 (scale 후에는 CSS 크기 사용)
  const cssWidth = ctx.canvas.width / pixelRatio;
  const cssHeight = ctx.canvas.height / pixelRatio;
  ctx.clearRect(0, 0, cssWidth, cssHeight);

  // 재귀 렌더링
  paintBox(root, ctx);
}

function paintBox(box: LayoutBox, ctx: CanvasRenderingContext2D): void {
  // 1. 배경 그리기
  if (box.style.background) {
    ctx.fillStyle = box.style.background;
    ctx.fillRect(box.x, box.y, box.width, box.height);
  }

  // 2. 테두리 그리기
  if (box.style.borderWidth && box.style.borderWidth !== "0") {
    const borderWidth = parsePx(box.style.borderWidth);
    ctx.strokeStyle = box.style.borderColor || "#000";
    ctx.lineWidth = borderWidth;
    ctx.strokeRect(
      box.x + borderWidth / 2,
      box.y + borderWidth / 2,
      box.width - borderWidth,
      box.height - borderWidth
    );
  }

  // 3. 텍스트 그리기
  if (box.nodeType === "text" && box.textContent) {
    const fontSize = parsePx(box.style.fontSize || "16px");
    ctx.font = `${box.style.fontWeight || "normal"} ${fontSize}px sans-serif`;
    ctx.fillStyle = box.style.color || "#000";
    ctx.fillText(box.textContent, box.x, box.y);
  }

  // 4. 자식 그리기
  for (const child of box.children) {
    paintBox(child, ctx);
  }
}
```

## 스타일 적용 함수 추가

```ts
// packages/core/css/style.ts
import { ComputedStyle } from "../layout/types";
import { DOMNode } from "../html/parser";
import { CSSRule } from "./parser";

/**
 * CSS 규칙을 DOM 노드에 적용
 */
export function applyStyles(dom: DOMNode, rules: CSSRule[]): void {
  // 재귀적으로 모든 노드에 스타일 적용
  applyStylesToNode(dom, rules);

  if (dom.children) {
    for (const child of dom.children) {
      applyStyles(child, rules);
    }
  }
}

function applyStylesToNode(node: DOMNode, rules: CSSRule[]): void {
  if (node.type !== "element") return;

  const computedStyle: ComputedStyle = node.computedStyle || {};

  // 각 CSS 규칙을 확인하여 매칭되는 경우 적용
  for (const rule of rules) {
    for (const selector of rule.selectors) {
      if (matchesSelector(node, selector)) {
        // 선언을 ComputedStyle 형식으로 변환하여 적용
        for (const [property, value] of Object.entries(rule.declarations)) {
          applyProperty(computedStyle, property, value);
        }
      }
    }
  }

  node.computedStyle = computedStyle;
}

/**
 * 노드가 선택자와 매칭되는지 확인
 */
function matchesSelector(node: DOMNode, selector: string): boolean {
  if (node.type !== "element" || !node.name) return false;

  selector = selector.trim();

  // 태그 선택자
  if (selector === node.name) {
    return true;
  }

  // ID 선택자 (#id)
  if (selector.startsWith("#")) {
    const id = selector.slice(1);
    return node.attrs?.id === id;
  }

  // 클래스 선택자 (.class)
  if (selector.startsWith(".")) {
    const className = selector.slice(1);
    const classAttr = node.attrs?.class || "";
    return classAttr.split(/\s+/).includes(className);
  }

  return false;
}

/**
 * CSS 속성을 ComputedStyle 형식으로 변환하여 적용
 */
function applyProperty(
  style: ComputedStyle,
  property: string,
  value: string
): void {
  // 단축 속성 처리
  if (property === "padding") {
    style.paddingTop = value;
    style.paddingRight = value;
    style.paddingBottom = value;
    style.paddingLeft = value;
    return;
  }

  if (property === "margin") {
    style.marginTop = value;
    style.marginRight = value;
    style.marginBottom = value;
    style.marginLeft = value;
    return;
  }

  if (property === "border") {
    // border: 2px solid #e1e4e8 형식 파싱
    const parts = value.trim().split(/\s+/);
    if (parts.length >= 1) {
      style.borderWidth = parts[0];
    }
    if (parts.length >= 2) {
      style.borderStyle = parts[1];
    }
    if (parts.length >= 3) {
      style.borderColor = parts.slice(2).join(" ");
    }
    return;
  }

  // 개별 속성 매핑
  const propertyMap: Record<string, keyof ComputedStyle> = {
    width: "width",
    height: "height",
    "margin-top": "marginTop",
    "margin-right": "marginRight",
    "margin-bottom": "marginBottom",
    "margin-left": "marginLeft",
    "padding-top": "paddingTop",
    "padding-right": "paddingRight",
    "padding-bottom": "paddingBottom",
    "padding-left": "paddingLeft",
    "border-width": "borderWidth",
    "border-color": "borderColor",
    "border-style": "borderStyle",
    background: "background",
    color: "color",
    "font-size": "fontSize",
    "font-weight": "fontWeight",
  };

  const mappedProperty = propertyMap[property];
  if (mappedProperty) {
    (style as any)[mappedProperty] = value;
  }
}
```

## Vite 개발 서버로 확인

이제 실제로 렌더링 결과를 확인해봅시다!

```html
// packages/apps/gui/index.html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Browser</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: #f0f0f0;
      }
      #screen {
        border: 1px solid #ccc;
        background: white;
        width: 100%;
        height: calc(100vh - 80px);
      }
    </style>
  </head>
  <body>
    <canvas id="screen"></canvas>
    <script type="module" src="/main.ts"></script>
  </body>
</html>
```

```json
// package.json
{
  "name": "browser-test",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "cd packages/apps/gui && vite",
    "build": "cd packages/apps/gui && vite build"
  },
  "devDependencies": {
    "@types/node": "^24.10.1",
    "typescript": "^5.0.0",
    "vite": "^5.0.0"
  }
}
```

```ts
// packages/apps/gui/vite.config.ts
import { defineConfig } from "vite";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { readFileSync } from "fs";
import { resolve } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  root: __dirname,
  server: { port: 5173 },
  plugins: [
    {
      name: "css-as-raw",
      configureServer(server) {
        server.middlewares.use((req, res, next) => {
          // CSS 파일 요청을 raw 텍스트로 반환 (vite는 기본적으로 CSS를 js로 변환하여 처리하기 때문에)
          if (req.url?.endsWith(".css") && !req.url.includes("?")) {
            try {
              // URL에서 파일 경로 추출 (예: /demo/demo.css -> demo/demo.css)
              const urlPath = req.url.startsWith("/")
                ? req.url.slice(1)
                : req.url;
              const filePath = resolve(__dirname, urlPath);
              const cssContent = readFileSync(filePath, "utf-8");
              res.setHeader("Content-Type", "text/css");
              res.end(cssContent);
              return;
            } catch (error) {
              // 파일을 찾을 수 없으면 다음 미들웨어로
              console.warn(`Failed to load CSS as raw: ${req.url}`, error);
            }
          }
          next();
        });
      },
    },
  ],
});
```

```typescript
// packages/apps/gui/main.ts

import { parseHTML } from "../../core/html/parser";
import { parseCSS } from "../../core/css/parser";
import { applyStyles } from "../../core/css/style";
import { layout } from "../../core/layout/engine";
import { paint } from "../../core/paint/painter";

const html = `
<html>
  <body>
    <div id="main" class="card">
      <h1>Hello Mini Browser</h1>
      <p>레이아웃 엔진이 작동합니다!</p>
    </div>
  </body>
</html>
`;

const css = `
body {
  background: #ffffff;
  padding: 20px;
}

#main {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
  margin: 20px;
}

h1 {
  font-size: 24px;
  color: #24292e;
  margin-bottom: 12px;
}

p {
  font-size: 16px;
  color: #586069;
}
`;

function setupCanvas(canvas: HTMLCanvasElement): CanvasRenderingContext2D {
  const ctx = canvas.getContext("2d")!;
  const pixelRatio = window.devicePixelRatio || 1;

  // CSS 크기
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;

  // 실제 픽셀 크기
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;

  // CSS 크기 유지
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;

  return ctx;
}

// DOM이 로드된 후 실행
window.addEventListener("DOMContentLoaded", () => {
  // 파싱
  const dom = parseHTML(html);
  const cssRules = parseCSS(css);

  // 스타일 적용
  applyStyles(dom, cssRules);

  // 레이아웃 계산
  const canvas = document.getElementById("screen") as HTMLCanvasElement;
  if (!canvas) {
    console.error("Canvas element not found");
    return;
  }

  const ctx = setupCanvas(canvas);
  const viewport = { width: 900, height: 600 };
  const layoutTree = layout(dom, viewport, ctx);

  // 페인팅
  paint(layoutTree, { ctx, pixelRatio: window.devicePixelRatio });
});
```

**실행**:

```bash
yarn install
yarn dev
```

브라우저에서 `http://localhost:5173` 접속하면 Canvas에 박스가 그려진 것을 볼 수 있습니다!

## 배운 것들

### 1. CSS 박스 모델의 실제 계산

- content-box vs border-box의 차이
- margin, padding, border 각각의 역할
- 마진 병합(margin collapse) 규칙

### 2. Reflow가 비싼 이유

레이아웃 계산은 재귀적으로 모든 노드를 순회하며:

- 부모의 너비가 변경되면 → 자식 모두 재계산
- 자식의 높이가 변경되면 → 부모의 높이 재계산
- 형제 요소의 위치도 다시 계산

이것이 바로 "Reflow"가 비싼 이유입니다!

### 3. Canvas API 기초

- `fillRect`: 사각형 채우기
- `strokeRect`: 사각형 테두리
- `fillText`: 텍스트 렌더링
- `measureText`: 텍스트 크기 측정

### 4. 텍스트 렌더링의 복잡성

- 폰트 크기, 굵기, 스타일
- line-height 계산
- 단어 감싸기(word wrapping)
- 다국어 지원 (우리는 단순화했지만...)

## 성능 최적화 팁

### 1. Reflow 최소화

```javascript
// 나쁜 예: 여러 번 Reflow 발생
element.style.width = "100px";
element.style.height = "200px";
element.style.margin = "10px";

// 좋은 예: 한 번만 Reflow
element.style.cssText = "width: 100px; height: 200px; margin: 10px;";
```

### 2. 레이아웃 속성 읽기 주의

```javascript
// 나쁜 예: 읽기와 쓰기를 섞으면 여러 번 Reflow
element.style.width = "100px";
const height = element.offsetHeight; // Reflow 강제 발생!
element.style.height = height + "px";

// 좋은 예: 읽기를 먼저, 쓰기는 나중에
const height = element.offsetHeight;
element.style.width = "100px";
element.style.height = height + "px";
```

### 3. requestAnimationFrame 사용

```javascript
// 브라우저 렌더링 사이클에 맞춰 업데이트
function animate() {
  // 레이아웃 변경
  element.style.transform = `translateX(${x}px)`;

  requestAnimationFrame(animate);
}
```

이제 준비됐습니다! **Part 3**에서는 이 모든 걸 하나로 합쳐서 **통합 렌더 파이프라인**을 완성합니다.

- 스타일 리졸버(Cascade 알고리즘)
- Shorthand 속성 처리
- 실제 HTML+CSS 파일 렌더링

## 참고 자료

- [CSS Box Model](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Box_Model)
- [Canvas API](https://developer.mozilla.org/ko/docs/Web/API/Canvas_API)
- [Reflow와 Repaint](https://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg)
