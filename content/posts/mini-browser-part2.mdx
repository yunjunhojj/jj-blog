---
title: "나만의 웹 브라우저 만들기 (2부) - 레이아웃 & 페인팅 엔진"
date: 2025-11-04
description: "CSS 박스 모델을 실제로 계산하고 Canvas에 렌더링하는 과정을 구현합니다. Reflow가 왜 비싼 연산인지 체감해보세요."
tags: ["Browser", "CSS", "Canvas", "Layout"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (2부) - 레이아웃 & 페인팅 엔진

> "브라우저는 `margin: 10px; width: 200px;` 같은 CSS를 어떻게 계산해서 화면에 배치할까?"

## 이전 편 복습

[Part 1](/posts/mini-browser-part1)에서 HTML과 CSS를 파싱하여 DOM 트리와 CSS 룰셋을 만들었습니다.

이제 이 데이터를 **실제 화면에 그릴** 차례입니다!

**오늘의 목표**:

1. **CSS 박스 모델** 이해 - 모든 요소가 박스라는 개념
2. **스타일 적용** - CSS 규칙을 DOM 노드에 매칭
3. **레이아웃 계산** - 각 요소의 위치와 크기 결정
4. **페인팅** - Canvas에 실제로 그리기

## CSS 박스 모델의 진실

모든 HTML 요소는 박스입니다. 이 박스는 4개의 영역으로 구성됩니다:

```
┌─────────────────────────┐
│      margin             │ ← 외부 여백
│  ┌───────────────────┐  │
│  │   border          │  │ ← 테두리
│  │ ┌───────────────┐ │  │
│  │ │  padding      │ │  │ ← 내부 여백
│  │ │ ┌───────────┐ │ │  │
│  │ │ │  content  │ │ │  │ ← 실제 내용
│  │ │ └───────────┘ │ │  │
│  │ └───────────────┘ │  │
│  └───────────────────┘  │
└─────────────────────────┘
```

### box-sizing 속성

**content-box (기본값)**:

```typescript
// width = content 영역의 너비
// 실제 요소가 차지하는 공간 = width + padding + border
const totalWidth =
  width + paddingLeft + paddingRight + borderLeft + borderRight;
```

**border-box (실무에서 선호)**:

```typescript
// width = content + padding + border 전체
// 실제 요소가 차지하는 공간 = width
const contentWidth =
  width - paddingLeft - paddingRight - borderLeft - borderRight;
```

### Margin Collapse (마진 병합)

인접한 블록 요소의 수직 마진은 병합됩니다:

```css
.box1 {
  margin-bottom: 20px;
}
.box2 {
  margin-top: 30px;
}
```

실제 간격은 `50px`이 아니라 `max(20px, 30px) = 30px`입니다!

## 스타일 적용 (Style Resolution)

레이아웃을 계산하기 전에, 먼저 각 DOM 노드에 어떤 CSS 규칙이 적용되는지 결정해야 합니다.

### 스타일 적용 과정

1. **선택자 매칭**: 각 노드가 CSS 선택자와 일치하는지 확인
2. **특이성 계산**: 여러 규칙이 충돌하면 우선순위 결정
3. **스타일 병합**: 적용되는 모든 스타일을 하나로 합침
4. **상속 처리**: 부모의 특정 속성(color, font 등)을 자식에게 전달

### 스타일 리졸버 구현

> 역할: 각 노드에 어떤 CSS 규칙이 적용되는지 결정하고, 스타일을 적용합니다.

```ts
//  packages/core/style/resolver.ts
import { DOMNode } from "../html/parser";
import { CSSRule } from "../css/parser";
import { matchesSelector } from "./matcher";
import {
  calculateSpecificity,
  compareSpecificity,
  Specificity,
} from "./specificity";
import { expandShorthands } from "./shorthand";
import { ComputedStyle } from "../layout/types";

export function applyStyles(dom: DOMNode, cssRules: CSSRule[]): void {
  // 모든 노드 순회
  traverseDOM(dom, (node) => {
    if (node.type !== "element") return;

    // 노드에 적용될 스타일을 우선순위별로 수집
    const applicableRules: Array<{
      rule: CSSRule;
      selector: string;
      specificity: Specificity;
    }> = [];

    for (const rule of cssRules) {
      for (const selector of rule.selectors) {
        if (matchesSelector(node, selector)) {
          applicableRules.push({
            rule,
            selector,
            specificity: calculateSpecificity(selector),
          });
        }
      }
    }

    // 특이성 순으로 정렬
    applicableRules.sort((a, b) =>
      compareSpecificity(a.specificity, b.specificity)
    );

    // 스타일 병합 (낮은 특이성 → 높은 특이성 순)
    node.computedStyle = {};
    for (const { rule } of applicableRules) {
      Object.assign(node.computedStyle, rule.declarations);
    }

    // Shorthand 속성 확장
    expandShorthands(node.computedStyle);

    // 상속 처리
    inheritStyles(node);
  });
}

function traverseDOM(node: DOMNode, callback: (node: DOMNode) => void): void {
  callback(node);
  if (node.children) {
    for (const child of node.children) {
      traverseDOM(child, callback);
    }
  }
}

// 상속 처리

const INHERITED_PROPERTIES = [
  "color",
  "fontSize",
  "fontWeight",
  "fontFamily",
  "lineHeight",
  "textAlign",
  "letterSpacing",
];

function inheritStyles(node: DOMNode): void {
  if (!node.parent || !node.parent.computedStyle) return;

  const parentStyle = node.parent.computedStyle;
  const nodeStyle = node.computedStyle || ({} as ComputedStyle);

  for (const prop of INHERITED_PROPERTIES) {
    // 명시적으로 지정되지 않았으면 부모에서 상속
    if (
      !nodeStyle[prop as keyof ComputedStyle] &&
      parentStyle[prop as keyof ComputedStyle]
    ) {
      nodeStyle[prop as keyof ComputedStyle] =
        parentStyle[prop as keyof ComputedStyle];
    }
  }

  node.computedStyle = nodeStyle;
}
```

### 선택자 매칭 구현

> CSS 선택자가 DOM 노드와 일치하는지 판단합니다.

```typescript
// packages/core/style/matcher.ts
import { DOMNode } from "../html/parser";

export function matchesSelector(node: DOMNode, selector: string): boolean {
  selector = selector.trim();

  // 후손 선택자 (공백 포함): .card h2, #main .title
  if (selector.includes(" ")) {
    const parts = selector.split(/\s+/).filter((s) => s);
    return matchesDescendantSelector(node, parts);
  }

  // 단일 선택자 매칭
  return matchesSingleSelector(node, selector);
}

/**
 * 단일 선택자 매칭 (ID, 클래스, 태그)
 */
function matchesSingleSelector(node: DOMNode, selector: string): boolean {
  if (!node || node.type !== "element") return false;

  // ID 선택자: #main
  if (selector.startsWith("#")) {
    const id = selector.slice(1);
    return node.attrs?.id === id;
  }

  // 클래스 선택자: .title
  if (selector.startsWith(".")) {
    const className = selector.slice(1);
    const classes = node.attrs?.class?.split(" ") || [];
    return classes.includes(className);
  }

  // 태그 선택자: div, h1, p
  return node.name === selector;
}

/**
 * 후손 선택자 매칭: .card h2, #main .title
 * parts = [".card", "h2"]인 경우:
 * 1. 현재 노드가 h2와 매칭되는지 확인
 * 2. 부모 체인에서 .card를 찾기
 */
function matchesDescendantSelector(node: DOMNode, parts: string[]): boolean {
  if (parts.length === 0) return true;
  if (parts.length === 1) return matchesSingleSelector(node, parts[0]);

  // 마지막 선택자가 현재 노드와 매칭되는지 확인
  const lastSelector = parts[parts.length - 1];
  if (!matchesSingleSelector(node, lastSelector)) {
    return false;
  }

  // 나머지 선택자들을 부모 체인에서 역순으로 찾기
  // 예: [".card", "h2"]에서 h2가 매칭되면, 부모 체인에서 .card를 찾음
  let currentParent = node.parent;
  let selectorIndex = parts.length - 2; // 뒤에서 두 번째부터 시작

  while (currentParent && selectorIndex >= 0) {
    if (matchesSingleSelector(currentParent, parts[selectorIndex])) {
      selectorIndex--;
      if (selectorIndex < 0) {
        // 모든 선택자가 매칭됨
        return true;
      }
    }
    currentParent = currentParent.parent;
  }

  return selectorIndex < 0;
}
```

### Shorthand 속성 확장

> `margin: 10px 20px;` 같은 단축 속성을 개별 속성으로 확장합니다.

```typescript
// packages/core/style/shorthand.ts
import { ComputedStyle } from "../layout/types";

export function expandShorthands(style: ComputedStyle): void {
  // margin shorthand 확장
  if (style.margin) {
    const values = parseBoxShorthand(style.margin);
    style.marginTop = values.top;
    style.marginRight = values.right;
    style.marginBottom = values.bottom;
    style.marginLeft = values.left;
    delete style.margin;
  }

  // padding shorthand 확장
  if (style.padding) {
    const values = parseBoxShorthand(style.padding);
    style.paddingTop = values.top;
    style.paddingRight = values.right;
    style.paddingBottom = values.bottom;
    style.paddingLeft = values.left;
    delete style.padding;
  }

  // border shorthand 확장: "2px solid #e1e4e8"
  if (style.border) {
    const borderParts = style.border.split(/\s+/);
    for (const part of borderParts) {
      if (part.match(/^\d+px$/)) {
        style.borderWidth = part;
      } else if (part.match(/^(solid|dashed|dotted)$/)) {
        style.borderStyle = part;
      } else if (part.match(/^#|^rgb|^rgba/)) {
        style.borderColor = part;
      }
    }
    delete style.border;
  }

  // 기본값 설정
  const hasMargin =
    style.marginTop !== undefined ||
    style.marginRight !== undefined ||
    style.marginBottom !== undefined ||
    style.marginLeft !== undefined;
  if (hasMargin) {
    style.marginTop = style.marginTop || "0";
    style.marginRight = style.marginRight || "0";
    style.marginBottom = style.marginBottom || "0";
    style.marginLeft = style.marginLeft || "0";
  }

  const hasPadding =
    style.paddingTop !== undefined ||
    style.paddingRight !== undefined ||
    style.paddingBottom !== undefined ||
    style.paddingLeft !== undefined;
  if (hasPadding) {
    style.paddingTop = style.paddingTop || "0";
    style.paddingRight = style.paddingRight || "0";
    style.paddingBottom = style.paddingBottom || "0";
    style.paddingLeft = style.paddingLeft || "0";
  }

  const hasBorder =
    style.borderWidth !== undefined ||
    style.borderStyle !== undefined ||
    style.borderColor !== undefined;
  if (hasBorder) {
    style.borderWidth = style.borderWidth || "0";
    style.borderStyle = style.borderStyle || "solid";
    style.borderColor = style.borderColor || "#000";
  }

  const hasFont =
    style.fontSize !== undefined || style.fontWeight !== undefined;
  if (hasFont) {
    style.fontSize = style.fontSize || "16px";
    style.fontWeight = style.fontWeight || "normal";
  }
}

/**
 * Box shorthand를 4방향 값으로 파싱
 * - 1개 값: 모두 동일
 * - 2개 값: top/bottom, left/right
 * - 3개 값: top, left/right, bottom
 * - 4개 값: top, right, bottom, left
 */
function parseBoxShorthand(value: string): {
  top: string;
  right: string;
  bottom: string;
  left: string;
} {
  const parts = value.trim().split(/\s+/);

  switch (parts.length) {
    case 1:
      return {
        top: parts[0],
        right: parts[0],
        bottom: parts[0],
        left: parts[0],
      };
    case 2:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[0],
        left: parts[1],
      };
    case 3:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[1],
      };
    case 4:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[3],
      };
    default:
      return { top: "0", right: "0", bottom: "0", left: "0" };
  }
}
```

### CSS 특이성 계산

> 여러 규칙이 충돌할 때 우선순위를 결정합니다.

```typescript
// packages/core/style/specificity.ts
export interface Specificity {
  inline: number; // style="..." (1000점)
  id: number; // #id (100점)
  class: number; // .class (10점)
  tag: number; // tag (1점)
}

export function calculateSpecificity(selector: string): Specificity {
  const spec: Specificity = { inline: 0, id: 0, class: 0, tag: 0 };

  // ID 선택자
  const ids = selector.match(/#[\w-]+/g);
  spec.id = ids ? ids.length : 0;

  // 클래스 선택자
  const classes = selector.match(/\.[\w-]+/g);
  spec.class = classes ? classes.length : 0;

  // 태그 선택자 (단순화)
  const tags = selector.match(/^[\w-]+|[\s>+~][\w-]+/g);
  spec.tag = tags ? tags.length : 0;

  return spec;
}

export function compareSpecificity(a: Specificity, b: Specificity): number {
  if (a.inline !== b.inline) return a.inline - b.inline;
  if (a.id !== b.id) return a.id - b.id;
  if (a.class !== b.class) return a.class - b.class;
  return a.tag - b.tag;
}
```

## 레이아웃 엔진 구현

> 이제 각 요소의 최종 위치와 크기를 계산합니다.

### LayoutBox 데이터 구조

레이아웃 계산의 결과물인 LayoutBox는 다음 정보를 담습니다:

- **위치**: x, y 좌표
- **크기**: width, height
- **스타일**: 계산된 최종 스타일
- **자식**: 중첩된 레이아웃 박스들

```typescript
//  packages/core/layout/types.ts

export interface LayoutBox {
  nodeId: number;
  nodeType: "element" | "text";
  tagName?: string;
  textContent?: string;

  // 계산된 스타일
  style: ComputedStyle;

  // 박스 위치와 크기
  x: number; // 화면 상 X 좌표
  y: number; // 화면 상 Y 좌표
  width: number; // border-box 너비
  height: number; // border-box 높이

  // 자식 박스들
  children: LayoutBox[];
}

export interface ComputedStyle {
  // 크기
  width?: string;
  height?: string;

  // shorthand
  margin?: string;
  padding?: string;
  border?: string;

  // 여백
  marginTop?: string;
  marginRight?: string;
  marginBottom?: string;
  marginLeft?: string;

  paddingTop?: string;
  paddingRight?: string;
  paddingBottom?: string;
  paddingLeft?: string;

  // 테두리
  borderWidth?: string;
  borderColor?: string;
  borderStyle?: string;

  // 배경 & 텍스트
  background?: string;
  color?: string;
  fontSize?: string;
  fontWeight?: string;
}
```

### 블록 레이아웃 알고리즘

```typescript
//  packages/core/layout/engine.ts
//  packages/core/html/parser.ts 에서 DOMNode에 computedStyle 주석 제거

import { ComputedStyle, LayoutBox } from "./types";
import { DOMNode } from "../html/parser";

export function layout(
  dom: DOMNode,
  viewport: { width: number; height: number },
  ctx: CanvasRenderingContext2D
): LayoutBox {
  return layoutBlock(dom, 0, 0, viewport.width, ctx);
}

function layoutBlock(
  node: DOMNode,
  x: number,
  y: number,
  parentWidth: number,
  ctx: CanvasRenderingContext2D
): LayoutBox {
  const style = node.computedStyle || {};

  // 1. 너비 계산
  let width = parentWidth;
  if (style.width) {
    if (style.width.endsWith("px")) {
      width = parsePx(style.width);
    } else if (style.width.endsWith("%")) {
      width = (parentWidth * parsePercent(style.width)) / 100;
    }
  }

  // 2. 여백 계산
  const margin = parseBoxValues(style, "margin");
  const padding = parseBoxValues(style, "padding");
  const border = parseBorderWidth(style.borderWidth || "0");

  // 3. content 영역 너비
  const contentWidth = width - padding.left - padding.right - border * 2;

  // 4. 실제 X, Y 위치 (margin 포함)
  const boxX = x + margin.left;
  const boxY = y + margin.top;

  // 5. 자식 레이아웃
  const children: LayoutBox[] = [];
  let childY = boxY + padding.top + border;

  if (node.children) {
    for (const child of node.children) {
      if (child.type === "element") {
        const childBox = layoutBlock(
          child,
          boxX + padding.left + border,
          childY,
          contentWidth,
          ctx
        );
        children.push(childBox);
        childY += childBox.height + parseMarginBottom(child);
      } else if (child.type === "text") {
        const textBox = layoutText(
          child,
          boxX + padding.left + border,
          childY,
          contentWidth,
          style,
          ctx
        );
        children.push(textBox);
        childY += textBox.height;
      }
    }
  }

  // 6. 높이 계산
  let height = padding.top + padding.bottom + border * 2;
  if (style.height && style.height.endsWith("px")) {
    height += parsePx(style.height);
  } else {
    // 자식 높이 합산
    height += childY - (boxY + padding.top + border);
  }

  return {
    nodeId: node.id || 0,
    nodeType: "element",
    tagName: node.name,
    style,
    x: boxX,
    y: boxY,
    width,
    height,
    children,
  };
}

function layoutText(
  node: DOMNode,
  x: number,
  y: number,
  maxWidth: number,
  parentStyle: ComputedStyle,
  ctx: CanvasRenderingContext2D
): LayoutBox {
  const text = node.text || "";
  const fontSize = parsePx(parentStyle.fontSize || "16px");

  // Canvas로 텍스트 크기 측정
  ctx.font = `${parentStyle.fontWeight || "normal"} ${fontSize}px sans-serif`;
  const metrics = ctx.measureText(text);
  const lineHeight = fontSize * 1.2; // 기본 line-height

  // 텍스트 baseline 위치 계산 (y는 content 영역의 top, baseline은 약간 아래)
  // 일반적으로 baseline은 line-height의 약 80% 지점에 위치
  const baselineOffset = fontSize * 0.8;

  return {
    nodeId: node.id || 0,
    nodeType: "text",
    textContent: text,
    style: parentStyle,
    x,
    y: y + baselineOffset, // 텍스트 baseline 위치
    width: Math.min(metrics.width, maxWidth),
    height: lineHeight,
    children: [],
  };
}

function parseBoxValues(
  style: ComputedStyle,
  prefix: "margin" | "padding"
): { top: number; right: number; bottom: number; left: number } {
  return {
    top: parsePx(style[`${prefix}Top`] || "0"),
    right: parsePx(style[`${prefix}Right`] || "0"),
    bottom: parsePx(style[`${prefix}Bottom`] || "0"),
    left: parsePx(style[`${prefix}Left`] || "0"),
  };
}

export function parsePx(value: string): number {
  return parseFloat(value) || 0;
}

function parsePercent(value: string): number {
  return parseFloat(value) || 0;
}

function parseBorderWidth(value: string): number {
  return parseFloat(value) || 0;
}

function parseMarginBottom(node: DOMNode): number {
  const style = node.computedStyle || {};
  return parsePx(style.marginBottom || "0");
}
```

## Canvas 페인터 구현

### 페인팅 순서

> 브라우저는 특정 순서로 요소를 그립니다.

1. **Background** (배경색/이미지)
2. **Border** (테두리)
3. **Content** (텍스트/이미지)
4. **Children** (자식 요소들)

```typescript
//  packages/core/paint/painter.ts

import { LayoutBox } from "../layout/types";
import { parsePx } from "../layout/engine";

export function paint(
  root: LayoutBox,
  options: {
    ctx: CanvasRenderingContext2D;
    pixelRatio: number;
  }
): void {
  const { ctx, pixelRatio } = options;

  // 이전 스케일링 상태 초기화 (repaint 시 누적 방지)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // HiDPI 대응
  ctx.scale(pixelRatio, pixelRatio);

  // 배경 클리어 (scale 후에는 CSS 크기 사용)
  const cssWidth = ctx.canvas.width / pixelRatio;
  const cssHeight = ctx.canvas.height / pixelRatio;
  ctx.clearRect(0, 0, cssWidth, cssHeight);

  // 재귀 렌더링
  paintBox(root, ctx);
}

function paintBox(box: LayoutBox, ctx: CanvasRenderingContext2D): void {
  // 1. 배경 그리기
  if (box.style.background) {
    ctx.fillStyle = box.style.background;
    ctx.fillRect(box.x, box.y, box.width, box.height);
  }

  // 2. 테두리 그리기
  if (box.style.borderWidth && box.style.borderWidth !== "0") {
    const borderWidth = parsePx(box.style.borderWidth);
    ctx.strokeStyle = box.style.borderColor || "#000";
    ctx.lineWidth = borderWidth;
    ctx.strokeRect(
      box.x + borderWidth / 2,
      box.y + borderWidth / 2,
      box.width - borderWidth,
      box.height - borderWidth
    );
  }

  // 3. 텍스트 그리기
  if (box.nodeType === "text" && box.textContent) {
    const fontSize = parsePx(box.style.fontSize || "16px");
    ctx.font = `${box.style.fontWeight || "normal"} ${fontSize}px sans-serif`;
    ctx.fillStyle = box.style.color || "#000";
    ctx.fillText(box.textContent, box.x, box.y);
  }

  // 4. 자식 그리기
  for (const child of box.children) {
    paintBox(child, ctx);
  }
}
```

## 실제 동작 확인하기

지금까지 만든 파서, 스타일 리졸버, 레이아웃 엔진, 페인터를 실제로 동작시켜서 테스트 해봅니다.

### 개발 환경 설정

Vite를 사용하여 빠르게 개발 서버를 띄우고 결과를 확인할 수 있습니다.
part2 에서는 로직을 간단하게 테스트 하기 위해 canvas 모드로 테스트 합니다.

```html
<!--  packages/apps/gui/index.html -->
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Mini Browser</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      #screen {
        width: 100%;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <!-- Canvas 모드일 때 -->
    <canvas id="screen"></canvas>

    <!-- Real DOM 모드일 때 (part5 에서 구현) -->
    <!-- <div id="screen"></div> -->

    <script type="module" src="/main.ts"></script>
  </body>
</html>
```

```json
// package.json
{
  "name": "mini-browser",
  "version": "1.0.0",
  "main": "packages/apps/gui/main.ts",
  "scripts": {
    "dev": "vite --config packages/apps/gui/vite.config.ts"
  },
  "devDependencies": {
    "@types/node": "^22.7.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.3",
    "vite": "^7.2.4"
  }
}
```

```ts
//  packages/apps/gui/vite.config.ts

import { defineConfig } from "vite";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { readFileSync } from "fs";
import { resolve } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  root: __dirname,
  server: { port: 5173 },
  plugins: [
    {
      name: "css-as-raw",
      configureServer(server) {
        server.middlewares.use((req, res, next) => {
          // CSS 파일 요청을 raw 텍스트로 반환 (vite는 기본적으로 CSS를 js로 변환하여 처리하기 때문에)
          if (req.url?.endsWith(".css") && !req.url.includes("?")) {
            try {
              // URL에서 파일 경로 추출 (예: /demo/demo.css -> demo/demo.css)
              const urlPath = req.url.startsWith("/")
                ? req.url.slice(1)
                : req.url;
              const filePath = resolve(__dirname, urlPath);
              const cssContent = readFileSync(filePath, "utf-8");
              res.setHeader("Content-Type", "text/css");
              res.end(cssContent);
              return;
            } catch (error) {
              // 파일을 찾을 수 없으면 다음 미들웨어로
              console.warn(`Failed to load CSS as raw: ${req.url}`, error);
            }
          }
          next();
        });
      },
    },
  ],
});
```

```typescript
// packages/apps/gui/part2.ts

import { parseHTML } from "../../core/html/parser";
import { parseCSS } from "../../core/css/parser";
import { applyStyles } from "../../core/style/resolver";
import { layout } from "../../core/layout/engine";
import { paint } from "../../core/paint/painter";
import { setupCanvas } from "../../core/utils/canvas";

const html = `
<html>
  <body>
    <div id="main" class="card">
      <h1>Hello Mini Browser</h1>
      <p>레이아웃 엔진이 작동합니다!</p>
    </div>
  </body>
</html>
`;

const css = `
body {
  background: #ffffff;
  padding: 20px;
}

#main {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
  margin: 20px;
}

h1 {
  font-size: 24px;
  color: #24292e;
  margin-bottom: 12px;
}

p {
  font-size: 16px;
  color: #586069;
}
`;

// DOM이 로드된 후 실행
window.addEventListener("DOMContentLoaded", () => {
  // 파싱
  const dom = parseHTML(html);
  const cssRules = parseCSS(css);

  // 스타일 적용
  applyStyles(dom, cssRules);

  // 레이아웃 계산
  const canvas = document.getElementById("screen") as HTMLCanvasElement;
  if (!canvas) {
    console.error("Canvas element not found");
    return;
  }

  const { ctx, viewport } = setupCanvas(canvas);
  const layoutTree = layout(dom, viewport, ctx);

  // 페인팅
  paint(layoutTree, { ctx, pixelRatio: window.devicePixelRatio });
});
```

**실행**:

```bash
yarn install
yarn dev
```

브라우저에서 `http://localhost:5173` 접속하면 Canvas에 스타일이 적용된 HTML이 렌더링된 것을 볼 수 있습니다!

## 핵심 개념 정리

### 1. 렌더링 파이프라인의 전체 흐름

이번 편에서 구현한 전체 과정을 다시 정리하면:

```
DOM 트리 + CSS 규칙
    ↓
선택자 매칭 & 스타일 계산
    ↓
LayoutBox 트리 (위치/크기 결정)
    ↓
Canvas에 페인팅
```

### 2. CSS 박스 모델

- **content-box vs border-box**: width가 무엇을 포함하는가?
- **margin, padding, border**: 각각의 역할과 계산 방식
- **마진 병합**: 인접한 마진이 합쳐지는 현상

### 3. Reflow가 비싼 이유

레이아웃 계산은 재귀적으로 모든 노드를 순회하며:

- 부모의 너비가 변경되면 → 자식 모두 재계산
- 자식의 높이가 변경되면 → 부모의 높이 재계산
- 형제 요소의 위치도 다시 계산

> 이것이 바로 "Reflow"가 비싼 이유

### 3. Canvas API 기초

- `fillRect`: 사각형 채우기
- `strokeRect`: 사각형 테두리
- `fillText`: 텍스트 렌더링
- `measureText`: 텍스트 크기 측정

### 4. 텍스트 렌더링의 복잡성

- 폰트 크기, 굵기, 스타일
- line-height 계산
- 단어 감싸기(word wrapping)
- 다국어 지원 (우리는 단순화했지만...)

## 성능 최적화 팁

### 1. Reflow 최소화

```javascript
// 나쁜 예: 여러 번 Reflow 발생
element.style.width = "100px";
element.style.height = "200px";
element.style.margin = "10px";

// 좋은 예: 한 번만 Reflow
element.style.cssText = "width: 100px; height: 200px; margin: 10px;";
```

### 2. 레이아웃 속성 읽기 주의

```javascript
// 나쁜 예: 읽기와 쓰기를 섞으면 여러 번 Reflow
element.style.width = "100px";
const height = element.offsetHeight; // Reflow 강제 발생!
element.style.height = height + "px";

// 좋은 예: 읽기를 먼저, 쓰기는 나중에
const height = element.offsetHeight;
element.style.width = "100px";
element.style.height = height + "px";
```

### 3. requestAnimationFrame 사용

```javascript
// 브라우저 렌더링 사이클에 맞춰 업데이트
function animate() {
  // 레이아웃 변경
  element.style.transform = `translateX(${x}px)`;

  requestAnimationFrame(animate);
}
```

## 참고 자료

- [CSS Box Model](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Box_Model)
- [Canvas API](https://developer.mozilla.org/ko/docs/Web/API/Canvas_API)
- [Reflow와 Repaint](https://dev.to/gopal1996/understanding-reflow-and-repaint-in-the-browser-1jbg)
