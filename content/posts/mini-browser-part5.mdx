---
title: "나만의 웹 브라우저 만들기 (5부) - Electron 데스크톱 앱"
date: 2025-11-15
description: "미니 브라우저를 Electron으로 데스크톱 앱화하고, Canvas 렌더링과 Real DOM 방식을 비교합니다. 시리즈 완결편!"
tags: ["Browser", "Electron", "Desktop", "DOM"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (5부) - Electron 데스크톱 앱

> "미니 브라우저를 브라우저 안에서만 쓰기엔 아깝다. 진짜 **데스크톱 앱**으로 만들자!"

## 이전 내용

- [Part 1](/posts/mini-browser-part1): HTML/CSS 파서
- [Part 2](/posts/mini-browser-part2): 레이아웃 & 페인팅
- [Part 3](/posts/mini-browser-part3): 통합 렌더 파이프라인
- [Part 4](/posts/mini-browser-part4): JavaScript 실행 환경

## Electron으로 데스크톱 앱 만들기

### Electron 소개

지금까지 브라우저 안에서 미니 브라우저를 실행했습니다. 이제 **독립적인 데스크톱 앱**으로 만들어보겠습니다.

Electron은 웹 기술(HTML, CSS, JavaScript)로 **네이티브 데스크톱 앱**을 만들 수 있게 해주는 프레임워크입니다.

**Electron의 2개 프로세스**:

```
Main Process (Node.js)
  ├─ BrowserWindow 생성
  ├─ 파일 시스템 접근
  ├─ 네이티브 메뉴
  └─ IPC (Inter-Process Communication)

Renderer Process (Chromium)
  └─ 우리의 Mini Browser 코드 실행
```

**사용 사례**:

- VS Code
- Slack
- Discord
- Figma Desktop

### 설치 및 설정

**package.json 수정**:

```json
{
  "name": "mini-browser",
  "version": "1.0.0",
  "main": "dist/electron/main.js",
  "scripts": {
    "dev:web": "vite --config packages/apps/gui/vite.config.ts",
    "dev:electron": "concurrently \"yarn dev:electron:watch\" \"yarn dev:electron:run\"",
    "dev": "concurrently \"yarn dev:web\" \"yarn dev:electron\""
  },
  "devDependencies": {
    "@types/node": "^22.7.5",
    "concurrently": "^9.2.1",
    "cross-env": "^10.1.0",
    "electron": "^39.2.3",
    "electron-builder": "^26.0.12",
    "nodemon": "^3.1.11",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5.6.3",
    "vite": "^7.2.4",
    "wait-on": "^9.0.3"
  }
}
```

```json
// tsconfig.electron.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "moduleResolution": "node",
    "rootDir": "electron",
    "outDir": "dist/electron",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "types": ["node", "electron"]
  },
  "include": ["electron/**/*.ts"]
}
```

```bash
yarn install
```

### Main Process 구현

```typescript
// electron/main.ts
import { app, BrowserWindow } from "electron";
import path from "path";
import http from "http";

let mainWindow: BrowserWindow | null = null;

async function createWindow() {
  // 개발/프로덕션 모두 컴파일된 파일 사용
  const preloadPath = path.join(__dirname, "preload.js");

  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: false,
      preload: preloadPath,
    },
    title: "Mini Browser",
  });

  // 개발 모드: Vite 서버 로드
  if (!app.isPackaged) {
    // Vite 서버가 준비될 때까지 대기
    const viteUrl = "http://localhost:5173";
    let retries = 30;
    let serverReady = false;

    console.log("Vite 서버 연결 대기 중...");
    while (retries > 0 && !serverReady) {
      try {
        await new Promise<void>((resolve, reject) => {
          const req = http.get(viteUrl, (res) => {
            if (res.statusCode === 200 || res.statusCode === 304) {
              serverReady = true;
              console.log("Vite 서버 연결 성공!");
              resolve();
            } else {
              reject(new Error(`Status: ${res.statusCode}`));
            }
          });
          req.on("error", (err) => {
            reject(new Error(`Connection failed: ${err.message}`));
          });
          req.setTimeout(1000, () => {
            req.destroy();
            reject(new Error("Timeout"));
          });
        });
        break;
      } catch {
        // 서버가 아직 준비되지 않음
        if (retries % 5 === 0) {
          console.log(`Vite 서버 대기 중... (${retries}회 남음)`);
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 1000));
      retries--;
    }

    if (!serverReady) {
      const errorHtml = `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="UTF-8">
            <title>Vite 서버 연결 실패</title>
            <style>
              body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background: #f5f5f5;
              }
              .error-box {
                background: white;
                padding: 40px;
                border-radius: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                max-width: 500px;
              }
              h1 { color: #d32f2f; margin-top: 0; }
              code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
            </style>
          </head>
          <body>
            <div class="error-box">
              <h1>Vite 서버를 찾을 수 없습니다</h1>
              <p>다음 명령어를 실행하여 Vite 개발 서버를 시작하세요:</p>
              <p><code>yarn dev:web</code></p>
              <p>또는</p>
              <p><code>yarn dev</code> (Vite와 Electron을 동시에 실행)</p>
            </div>
          </body>
        </html>
      `;
      await mainWindow.loadURL(
        `data:text/html;charset=utf-8,${encodeURIComponent(errorHtml)}`
      );
      mainWindow.webContents.openDevTools();
      return;
    }

    try {
      await mainWindow.loadURL(viteUrl);
      mainWindow.webContents.openDevTools();

      // 로드 실패 감지
      mainWindow.webContents.on(
        "did-fail-load",
        (event, errorCode, errorDescription) => {
          console.error("페이지 로드 실패:", errorCode, errorDescription);
        }
      );
    } catch (error) {
      console.error("URL 로드 중 오류:", error);
    }
  }
  // 프로덕션: 빌드된 HTML 로드
  else {
    const projectRoot = path.resolve(
      __dirname,
      app.isPackaged ? ".." : "",
      ".."
    );
    await mainWindow.loadFile(
      path.join(projectRoot, "packages/apps/gui/dist/index.html")
    );
  }

  mainWindow.on("closed", () => {
    mainWindow = null;
  });
}

app.whenReady().then(createWindow);

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
```

### Preload Script (선택사항)

```typescript
// electron/preload.ts

import { contextBridge, ipcRenderer } from "electron";

contextBridge.exposeInMainWorld("electronAPI", {
  openFile: () => ipcRenderer.invoke("dialog:openFile"),
  saveFile: (data: string) => ipcRenderer.invoke("dialog:saveFile", data),
});
```

### 실행

```bash
# 실행
yarn dev
```

## Real DOM 렌더링 모드 구현

지금까지는 Canvas에 직접 그렸습니다. 이제 **실제 브라우저처럼** HTML 요소를 생성하는 방식으로 전환해봅시다!

### Canvas vs Real DOM

- **Canvas 모드**: 우리가 직접 픽셀 하나하나를 제어
- **Real DOM 모드**: 브라우저에게 렌더링을 맡김

### Real DOM 생성 함수

```typescript
// packages/core/utils/renderDOM.ts

import { ComputedStyle } from "../layout/types";
import { DOMNode, parseHTML } from "../html/parser";
import { JSInterpreter } from "../js/interpreter";
import { EventLoop } from "../runtime/loop/eventLoop";
import { extractScripts } from "../runtime/dom/utils";
import { parseCSS } from "../css/parser";
import { loadResources } from "./loadResources";
import { applyStyles } from "../style/resolver";

export function createRealDOM(node: DOMNode): HTMLElement | Text | null {
  // 텍스트 노드
  if (node.type === "text") {
    return document.createTextNode(node.text || "");
  }

  // 요소 노드
  if (node.type === "element") {
    // script 태그는 DOM에 추가하지 않음 (JSInterpreter로 별도 실행)
    if (node.name === "script") {
      return null;
    }

    const element = document.createElement(node.name || "div");

    // 1. 속성 적용
    for (const attr in node.attrs) {
      element.setAttribute(attr, node.attrs[attr]);
    }

    // 2. 스타일 적용
    if (node.computedStyle) {
      applyStylesToElement(element, node.computedStyle);
    }

    // 3. 자식 재귀 생성
    if (node.children) {
      for (const child of node.children) {
        const childElement = createRealDOM(child);
        if (childElement) {
          element.appendChild(childElement);
        }
      }
    }

    return element;
  }

  return null;
}

function applyStylesToElement(
  element: HTMLElement,
  style: ComputedStyle
): void {
  for (const key in style) {
    // kebab-case → camelCase 변환
    const camelKey = key.replace(/-([a-z])/g, (g) =>
      g[1].toUpperCase()
    ) as keyof CSSStyleDeclaration & keyof ComputedStyle;
    element.style[camelKey] = style[key as keyof ComputedStyle] as string;
  }
}

export async function renderPageToDOM({
  htmlUrl,
  cssUrl,
  container,
}: {
  htmlUrl: string;
  cssUrl: string;
  container: HTMLElement;
}): Promise<void> {
  // 1~3. HTML/CSS 로드 및 스타일 적용
  // 1. 리소스 로드
  console.time("Load Resources");
  const { htmlText, cssText } = await loadResources(htmlUrl, cssUrl);
  console.timeEnd("Load Resources");

  // 2. 파싱
  console.time("Parse HTML");
  const dom = parseHTML(htmlText);
  console.timeEnd("Parse HTML");

  console.time("Parse CSS");
  const cssRules = parseCSS(cssText);
  console.timeEnd("Parse CSS");

  // 3. 스타일 적용
  console.time("Apply Styles");
  applyStyles(dom, cssRules);
  console.timeEnd("Apply Styles");
  // 4. 실제 DOM 생성
  const realDOM = createRealDOM(dom);

  // 5. 컨테이너에 추가
  container.innerHTML = "";
  if (realDOM) {
    container.appendChild(realDOM);
  }
  // 6. JavaScript 실행
  const scripts = extractScripts(dom);
  if (scripts.length > 0) {
    const bindings = createSimpleDOMBindings(container);
    const interpreter = new JSInterpreter(bindings, new EventLoop());

    for (const code of scripts) {
      try {
        interpreter.run(code);
      } catch (error) {
        console.error("Script execution error:", error);
      }
    }
  }
}

/**
 * Real DOM 모드에서 사용할 간단한 DOM 바인딩을 생성합니다.
 * 타이머 API는 JSInterpreter가 자동으로 제공합니다.
 */
function createSimpleDOMBindings(root: HTMLElement): Record<string, unknown> {
  return {
    document: {
      createElement: (tag: string) => document.createElement(tag),
      createTextNode: (text: string) => document.createTextNode(text),
      appendChild: (node: Node) => root.appendChild(node),
      querySelector: (selector: string) => root.querySelector(selector),
      querySelectorAll: (selector: string) => root.querySelectorAll(selector),
      getElementById: (id: string) => document.getElementById(id),
      addEventListener: (event: string, handler: EventListener) => {
        root.addEventListener(event, handler);
      },
      removeEventListener: (event: string, handler: EventListener) => {
        root.removeEventListener(event, handler);
      },
    },
    console,
    alert: (msg: unknown) => {
      const alertDiv = document.createElement("div");
      alertDiv.textContent = `Alert: ${String(msg)}`;
      alertDiv.style.cssText = `
        background: #ffeeba;
        border: 1px solid #ffc107;
        padding: 10px;
        color: #856404;
        margin: 10px 0;
      `;
      root.appendChild(alertDiv);
    },
  };
}
```

### part5.ts

```typescript
// packages/apps/gui/part5.ts

import { renderPage } from "../../core/utils/render";
import { renderPageToDOM } from "../../core/utils/renderDOM";
import { setupCanvas } from "../../core/utils/canvas";

const MODE: "canvas" | "dom" = "dom"; // "canvas" 또는 "dom"

async function main() {
  const htmlUrl = "/part5.html";
  const cssUrl = "/part3.css";

  if (MODE === "canvas") {
    // Canvas 모드
    const canvas = document.getElementById("screen") as HTMLCanvasElement;
    const { ctx, viewport } = setupCanvas(canvas);

    await renderPage({
      htmlUrl,
      cssUrl,
      ctx,
      viewport,
    });
  } else {
    // Real DOM 모드
    const container = document.getElementById("screen") as HTMLDivElement;

    await renderPageToDOM({
      htmlUrl,
      cssUrl,
      container,
    });
  }
}

main().catch(console.error);
```

## Canvas vs Real DOM 비교

### 실전 데모

```html
<!-- packages/apps/gui/part5.html -->
<!DOCTYPE html>
<html>
  <body>
    <div id="main">
      <h1>Real DOM Demo</h1>
      <p>이 텍스트는 드래그로 선택할 수 있습니다!</p>
      <button id="btn">Click Me</button>
      <div id="output"></div>

      <script>
        console.log("Script loaded!");
        const btn = document.querySelector("#btn");
        btn.addEventListener("click", () => {
          alert("Real DOM 모드에서 작동합니다!");

          console.log("Button clicked!");

          const output = document.querySelector("#output");
          const p = document.createElement("p");
          p.textContent = "버튼이 클릭되었습니다!";
          output.appendChild(p);
        });
      </script>
    </div>
  </body>
</html>
```

packages/apps/gui/index.html 에서 <!-- Real DOM 모드일 때 --> 주석 제거

### 결과 비교

직접 실행해보면 두 모드의 차이를 명확히 느낄 수 있습니다:

**Canvas 모드** (우리가 직접 구현):

- 텍스트 드래그 불가 - 그냥 그림이기 때문
- 버튼 클릭 감지를 좌표 계산으로 직접 구현해야 함
- 개발자 도구로 요소 검사 불가 - Canvas만 보임

**Real DOM 모드** (브라우저 활용):

- 텍스트 드래그로 선택 가능 - 진짜 HTML 요소
- 버튼 클릭이 네이티브로 동작 - 브라우저가 처리
- 개발자 도구로 요소 검사 가능 - 실제 DOM 트리

## Canvas vs Real DOM: 완전 비교

| 기능               | Canvas 모드             | Real DOM 모드            |
| ------------------ | ----------------------- | ------------------------ |
| **텍스트 선택**    | 불가능 (그림일 뿐)      | 가능 (진짜 텍스트)       |
| **링크 클릭**      | 좌표 계산으로 직접 구현 | 브라우저가 자동처리      |
| **개발자 도구**    | Canvas만 보임           | 요소 검사 가능           |
| **CSS 애니메이션** | 직접 구현 필요          | 브라우저가 처리          |
| **접근성(a11y)**   | 스크린 리더 불가        | 웹 표준 지원             |
| **성능**           | 수동 최적화 필요        | 브라우저 최적화          |
| **학습 효과**      | 렌더링 원리를 이해      | 브라우저에 의존하여 이해 |

**Canvas 모드의 진짜 가치**:

- 브라우저 렌더링 엔진의 내부 동작 원리를 체감
- Reflow/Repaint가 왜 비싼지 실제로 구현하며 이해
- 완전한 제어권 - 커스텀 렌더링 엔진을 만들 수 있는 기반

## 시리즈 완료

5개 파트로 **브라우저 렌더링 파이프라인 전체**를 구현했습니다.

### 시리즈를 통해 배운 것들

**Part 1 - HTML/CSS 파서**

- 토크나이저와 파서의 동작 원리
- DOM 트리의 계층 구조
- CSS 선택자와 룰셋

**Part 2 - 레이아웃 & 페인팅**

- CSS 박스 모델의 실제 계산
- 블록 레이아웃 알고리즘
- Reflow가 비싼 이유
- Canvas API와 HiDPI 지원

**Part 3 - 렌더 파이프라인**

- Cascade 알고리즘과 특이성
- 스타일 상속 처리
- 전체 파이프라인 통합

**Part 4 - JavaScript 실행 환경**

- 인터프리터 구현 전략
- DOM API 바인딩
- 이벤트 루프 (Macro/Micro Task)
- 비동기 처리 메커니즘

**Part 5 - Electron & Real DOM**

- 데스크톱 앱 패키징
- Main/Renderer Process 분리
- Canvas vs Real DOM 비교

### 실무에 적용할 수 있는 인사이트

이 지식은 실제 웹 개발에서 다음과 같이 활용할 수 있습니다:

- **성능 최적화**: Reflow/Repaint를 줄이는 코드 작성
- **CSS 디버깅**: 특이성 충돌 문제를 빠르게 해결
- **비동기 처리**: 이벤트 루프 이해로 버그 예방
- **프레임워크 이해**: React, Vue의 Virtual DOM이 왜 필요한지 이해

## 마무리

**브라우저는 마법이 아닙니다.** 이 시리즈를 통해 겉보기엔 복잡해 보이는 브라우저도, 결국:

- 텍스트를 파싱하고
- 스타일을 계산하고
- 레이아웃을 그리고
- 이벤트를 처리하는

**작은 모듈들의 조합**이라는 것을 확인했습니다.

> "복잡해 보이는 시스템도 결국 이해 가능한 작은 조각들로 이루어져 있다."

## 전체 시리즈 링크

- [Part 1: HTML/CSS 파서 구현](/posts/mini-browser-part1)
- [Part 2: 레이아웃 & 페인팅 엔진](/posts/mini-browser-part2)
- [Part 3: 통합 렌더 파이프라인](/posts/mini-browser-part3)
- [Part 4: JavaScript 실행 환경](/posts/mini-browser-part4)
- [Part 5: Electron 데스크톱 앱](/posts/mini-browser-part5) (현재)

## 참고 자료

- [Electron Documentation](https://www.electronjs.org/docs/latest/)
- [How Browsers Work](https://web.dev/howbrowserswork/)
- [Inside look at modern web browser](https://developer.chrome.com/blog/inside-browser-part1/)
- [Life of a Pixel](https://www.youtube.com/watch?v=PwYxv-43iM4)
