---
title: "나만의 웹 브라우저 만들기 (3부) - 통합 렌더 파이프라인"
date: 2025-11-07
description: "HTML 파싱, CSS 파싱, 레이아웃, 페인팅을 하나로 합쳐 완전한 렌더링 파이프라인을 완성합니다. Cascade 알고리즘도 구현합니다."
tags: ["Browser", "CSS", "Cascade", "Pipeline"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (3부) - 통합 렌더 파이프라인

> "앞에 작성한 코드를 어떻게 하나로 합칠까?"

## 이전 내용 복습

지금까지 만든 것들:

- [Part 1](/posts/mini-browser-part1): HTML/CSS 파서 - 텍스트를 구조화된 데이터로
- [Part 2](/posts/mini-browser-part2): 스타일 적용, 레이아웃, 페인팅 - 데이터를 화면으로

이제 이 모든 조각을 **하나의 렌더링 파이프라인**으로 통합하고, 실제 HTML/CSS 파일을 로드하여 렌더링해보겠습니다.

## 전체 파이프라인 시각화

```
HTML 문자열 ──→ [parseHTML] ──→ DOM 트리
                                    ↓
CSS 문자열 ──→ [parseCSS] ──→ CSS 룰셋
                                    ↓
                        [applyStyles] ──→ DOM + ComputedStyle
                                    ↓
                          [layout] ──→ LayoutBox 트리
                                    ↓
                          [paint] ──→ Canvas 출력
```

## 리소스 로더 구현

실제 브라우저처럼 외부 HTML/CSS 파일을 불러오는 기능이 필요합니다.

### 파일 로딩 유틸리티

```typescript
//  packages/core/utils/loadResources.ts

async function fetchTextResource(url: string, label: string): Promise<string> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(
      `Failed to load ${label}: ${response.status} ${response.statusText}`
    );
  }
  return await response.text();
}

export async function loadHTML(url: string): Promise<string> {
  return fetchTextResource(url, "HTML");
}

export async function loadCSS(url: string): Promise<string> {
  return fetchTextResource(url, "CSS");
}

export async function loadResources(htmlUrl: string, cssUrl: string) {
  const [htmlText, cssText] = await Promise.all([
    loadHTML(htmlUrl),
    loadCSS(cssUrl),
  ]);
  return { htmlText, cssText };
}
```

## 통합 렌더링 함수

모든 단계를 하나로 묶는 `renderPage` 함수를 만들어봅시다. 이 함수는:

1. HTML/CSS 파일을 로드
2. 파싱
3. 스타일 적용
4. 레이아웃 계산
5. 페인팅

을 순차적으로 실행합니다.

```typescript
//  packages/core/utils/render.ts

import { layout } from "../layout/engine";
import { paint } from "../paint/painter";
import { LayoutBox } from "../layout/types";
import { DOMNode, parseHTML } from "../html/parser";
import { loadResources } from "../utils/loadResources";
import { applyStyles } from "../style/resolver";
import { parseCSS } from "../css/parser";

export interface RenderOptions {
  htmlUrl: string;
  cssUrl: string;
  ctx: CanvasRenderingContext2D;
  viewport: {
    width: number;
    height: number;
  };
}

export interface RenderResult {
  dom: DOMNode;
  layoutTree: LayoutBox;
}

export async function renderPage(
  options: RenderOptions
): Promise<RenderResult> {
  const { htmlUrl, cssUrl, ctx, viewport } = options;
  console.time("Prepare DOM");
  // 1. 리소스 로드
  console.time("Load Resources");
  const { htmlText, cssText } = await loadResources(htmlUrl, cssUrl);
  console.timeEnd("Load Resources");

  // 2. 파싱
  console.time("Parse HTML");
  const dom = parseHTML(htmlText);
  console.timeEnd("Parse HTML");

  console.time("Parse CSS");
  const cssRules = parseCSS(cssText);
  console.timeEnd("Parse CSS");

  // 3. 스타일 적용
  console.time("Apply Styles");
  applyStyles(dom, cssRules);
  console.timeEnd("Apply Styles");

  // 레이아웃 계산
  console.time("Layout");
  const layoutTree = layout(dom, viewport, ctx);
  console.timeEnd("Layout");

  // 페인팅
  console.time("Paint");
  const pixelRatio = window.devicePixelRatio || 1;
  paint(layoutTree, { ctx, pixelRatio });
  console.timeEnd("Paint");

  console.log("---- Render complete! ----");

  return { dom, layoutTree };
}
```

## 실전 데모

### part3.html

```html
<!-- packages/apps/gui/part3.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Mini Browser Demo</title>
  </head>
  <body>
    <div id="main" class="container">
      <h1 class="title">Hello Mini Browser</h1>
      <p class="description">이것은 우리가 만든 미니 브라우저입니다!</p>
      <div class="note">CSS 스타일링이 완벽하게 작동합니다.</div>
      <div class="card">
        <h2>박스 모델 테스트</h2>
        <p>margin, padding, border가 모두 적용됩니다.</p>
      </div>
    </div>
  </body>
</html>
```

### part3.css

```css
/* packages/apps/gui/part3.css */

body {
  background: #fff;
  font-size: 16px;
  padding: 20px;
  margin: 0;
}

#main {
  background: #f6f8fa;
  border: 2px solid #f82d0e;
  padding: 20px;
  margin: 20px auto;
}

.title {
  font-size: 16px;
  font-weight: bold;
  color: #0e60b2;
  margin-bottom: 16px;
}

.description {
  font-size: 12px;
  color: #586069;
  margin-bottom: 20px;
}

.note {
  background: #fff3cd;
  border: 1px solid #ffeeba;
  padding: 12px;
  margin-bottom: 20px;
  color: #856404;
}

.card {
  background: #ffffff;
  border: 1px solid #e1e4e8;
  padding: 16px;
}

.card h2 {
  font-size: 20px;
  color: #0e60b2;
  margin-bottom: 8px;
}

.card p {
  font-size: 14px;
  color: #586069;
}
```

### part3.ts

```typescript
// packages/apps/gui/part3.ts

import { renderPage } from "../../core/render";
import { setupCanvas } from "../../core/utils/canvas";

async function main() {
  const canvas = document.getElementById("screen") as HTMLCanvasElement;
  const { ctx, viewport } = setupCanvas(canvas);

  await renderPage({
    htmlUrl: "/part3.html",
    cssUrl: "/part3.css",
    ctx,
    viewport,
  });
}

main().catch(console.error);
```

packages/apps/gui/index.html 에서 script 태그를 수정해서 part3.ts 파일을 실행합니다.

```html
<!-- 다른 내용은 유지 -->
<script type="module" src="/part3.ts"></script>
```

```bash
yarn install
yarn dev
```

**실행 결과**: Canvas에 배경색, 테두리, 여백이 정확히 적용된 HTML이 렌더링됩니다.

## 성능 분석

`console.time`으로 각 단계의 소요 시간을 측정했습니다. 개발자 도구 콘솔을 열어 확인 가능합니다.

**분석 결과**:

- **네트워크 로딩** (가장 오래 걸림): HTML/CSS 파일을 가져오는 시간. 실제 브라우저에서는 HTTP 캐시로 최적화합니다.
- **레이아웃 계산** (두 번째로 느림): 모든 노드를 순회하며 위치/크기를 계산. Reflow가 비싼 이유를 체감할 수 있습니다.
- **파싱과 페인팅** (상대적으로 빠름): 최적화가 잘 된 영역입니다.

## 핵심 개념 정리

### 1. 렌더링 파이프라인 통합

이제 브라우저의 전체 렌더링 과정을 하나의 함수로 실행할 수 있게 되었습니다.

```
URL 입력 → 리소스 로드 → 파싱 → 스타일 적용 → 레이아웃 → 페인팅 → 화면 출력
```

### 2. 비동기 처리의 중요성

`Promise.all`로 병렬 로딩하여 성능을 개선했습니다.

```typescript
// HTML과 CSS를 동시에 fetch (병렬 처리)
const [htmlText, cssText] = await Promise.all([
  loadHTML(htmlUrl),
  loadCSS(cssUrl),
]);
```

## 최적화 아이디어

### 1. 증분 레이아웃

```typescript
// 변경된 노드만 재계산
function incrementalLayout(changedNode: DOMNode) {
  // 1. 영향받는 부모 체인 찾기
  const affectedNodes = getAffectedParents(changedNode);

  // 2. 해당 서브트리만 레이아웃 재계산
  for (const node of affectedNodes) {
    layoutSubtree(node);
  }
}
```

### 2. 스타일 캐싱

```typescript
// 한 번 계산한 스타일을 캐싱
const styleCache = new Map<string, ComputedStyle>();

function getComputedStyle(node: DOMNode): ComputedStyle {
  const cacheKey = getNodeKey(node);
  if (styleCache.has(cacheKey)) {
    return styleCache.get(cacheKey)!;
  }

  const style = calculateStyle(node);
  styleCache.set(cacheKey, style);
  return style;
}
```

## 참고 자료

- [CSS Cascade and Inheritance](https://www.w3.org/TR/css-cascade-3/)
- [CSS Specificity](https://developer.mozilla.org/ko/docs/Web/CSS/Specificity)
- [Rendering Performance](https://web.dev/rendering-performance/)
