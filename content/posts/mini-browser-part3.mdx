---
title: "나만의 웹 브라우저 만들기 (3부) - 통합 렌더 파이프라인"
date: 2025-11-07
description: "HTML 파싱, CSS 파싱, 레이아웃, 페인팅을 하나로 합쳐 완전한 렌더링 파이프라인을 완성합니다. Cascade 알고리즘도 구현합니다."
tags: ["Browser", "CSS", "Cascade", "Pipeline"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (3부) - 통합 렌더 파이프라인

> "앞에 작성한 코드를 어떻게 하나로 합칠까?"

## 이전 내용 복습

- [Part 1](/posts/mini-browser-part1): HTML/CSS 파서 구현
- [Part 2](/posts/mini-browser-part2): 레이아웃 & 페인팅 엔진

이제 이 모든 조각을 하나로 합쳐 **렌더링 파이프라인**을 만들어야 합니다.

## 전체 파이프라인 시각화

```
HTML 문자열 ──→ [parseHTML] ──→ DOM 트리
                                    ↓
CSS 문자열 ──→ [parseCSS] ──→ CSS 룰셋
                                    ↓
                        [applyStyles] ──→ DOM + ComputedStyle
                                    ↓
                          [layout] ──→ LayoutBox 트리
                                    ↓
                          [paint] ──→ Canvas 출력
```

## 스타일 리졸버 구현

### CSS Cascade 알고리즘

브라우저는 여러 CSS 룰이 하나의 요소에 적용될 때, 다음 순서로 우선순위를 결정합니다:

1. **특이성(Specificity)** 계산
2. **선언 순서** (나중에 선언된 것이 우선)
3. **상속**(Inheritance)

### 특이성 계산

```typescript
// packages/core/style/specificity.ts
export interface Specificity {
  inline: number; // style="..." (1000점)
  id: number; // #id (100점)
  class: number; // .class (10점)
  tag: number; // tag (1점)
}

export function calculateSpecificity(selector: string): Specificity {
  const spec: Specificity = { inline: 0, id: 0, class: 0, tag: 0 };

  // ID 선택자
  const ids = selector.match(/#[\w-]+/g);
  spec.id = ids ? ids.length : 0;

  // 클래스 선택자
  const classes = selector.match(/\.[\w-]+/g);
  spec.class = classes ? classes.length : 0;

  // 태그 선택자 (단순화)
  const tags = selector.match(/^[\w-]+|[\s>+~][\w-]+/g);
  spec.tag = tags ? tags.length : 0;

  return spec;
}

export function compareSpecificity(a: Specificity, b: Specificity): number {
  if (a.inline !== b.inline) return a.inline - b.inline;
  if (a.id !== b.id) return a.id - b.id;
  if (a.class !== b.class) return a.class - b.class;
  return a.tag - b.tag;
}
```

### 선택자 매칭

```typescript
// packages/core/style/matcher.ts
import { DOMNode } from "../html/parser";

export function matchesSelector(node: DOMNode, selector: string): boolean {
  selector = selector.trim();

  // 후손 선택자 (공백 포함): .card h2, #main .title
  if (selector.includes(" ")) {
    const parts = selector.split(/\s+/).filter((s) => s);
    return matchesDescendantSelector(node, parts);
  }

  // 단일 선택자 매칭
  return matchesSingleSelector(node, selector);
}

/**
 * 단일 선택자 매칭 (ID, 클래스, 태그)
 */
function matchesSingleSelector(node: DOMNode, selector: string): boolean {
  if (!node || node.type !== "element") return false;

  // ID 선택자: #main
  if (selector.startsWith("#")) {
    const id = selector.slice(1);
    return node.attrs?.id === id;
  }

  // 클래스 선택자: .title
  if (selector.startsWith(".")) {
    const className = selector.slice(1);
    const classes = node.attrs?.class?.split(" ") || [];
    return classes.includes(className);
  }

  // 태그 선택자: div, h1, p
  return node.name === selector;
}

/**
 * 후손 선택자 매칭: .card h2, #main .title
 * parts = [".card", "h2"]인 경우:
 * 1. 현재 노드가 h2와 매칭되는지 확인
 * 2. 부모 체인에서 .card를 찾기
 */
function matchesDescendantSelector(node: DOMNode, parts: string[]): boolean {
  if (parts.length === 0) return true;
  if (parts.length === 1) return matchesSingleSelector(node, parts[0]);

  // 마지막 선택자가 현재 노드와 매칭되는지 확인
  const lastSelector = parts[parts.length - 1];
  if (!matchesSingleSelector(node, lastSelector)) {
    return false;
  }

  // 나머지 선택자들을 부모 체인에서 역순으로 찾기
  // 예: [".card", "h2"]에서 h2가 매칭되면, 부모 체인에서 .card를 찾음
  let currentParent = node.parent;
  let selectorIndex = parts.length - 2; // 뒤에서 두 번째부터 시작

  while (currentParent && selectorIndex >= 0) {
    if (matchesSingleSelector(currentParent, parts[selectorIndex])) {
      selectorIndex--;
      if (selectorIndex < 0) {
        // 모든 선택자가 매칭됨
        return true;
      }
    }
    currentParent = currentParent.parent;
  }

  return selectorIndex < 0;
}
```

### 스타일 적용

```typescript
// packages/core/style/resolver.ts
import { DOMNode } from "../html/parser";
import { CSSRule } from "../css/parser";
import { matchesSelector } from "./matcher";
import {
  calculateSpecificity,
  compareSpecificity,
  Specificity,
} from "./specificity";
import { expandShorthands } from "./shorthand";

export function applyStyles(dom: DOMNode, cssRules: CSSRule[]): void {
  // 모든 노드 순회
  traverseDOM(dom, (node) => {
    if (node.type !== "element") return;

    // 노드에 적용될 스타일을 우선순위별로 수집
    const applicableRules: Array<{
      rule: CSSRule;
      selector: string;
      specificity: Specificity;
    }> = [];

    for (const rule of cssRules) {
      for (const selector of rule.selectors) {
        if (matchesSelector(node, selector)) {
          applicableRules.push({
            rule,
            selector,
            specificity: calculateSpecificity(selector),
          });
        }
      }
    }

    // 특이성 순으로 정렬
    applicableRules.sort((a, b) =>
      compareSpecificity(a.specificity, b.specificity)
    );

    // 스타일 병합 (낮은 특이성 → 높은 특이성 순)
    node.computedStyle = {};
    for (const { rule } of applicableRules) {
      Object.assign(node.computedStyle, rule.declarations);
    }

    // Shorthand 속성 확장
    expandShorthands(node.computedStyle);

    // 상속 처리
    inheritStyles(node);
  });
}

function traverseDOM(node: DOMNode, callback: (node: DOMNode) => void): void {
  callback(node);
  if (node.children) {
    for (const child of node.children) {
      traverseDOM(child, callback);
    }
  }
}

// 상속 처리
const INHERITED_PROPERTIES = [
  "color",
  "fontSize",
  "fontWeight",
  "fontFamily",
  "lineHeight",
  "textAlign",
  "letterSpacing",
];

function inheritStyles(node: DOMNode): void {
  if (!node.parent || !node.parent.computedStyle) return;

  const parentStyle = node.parent.computedStyle;
  const nodeStyle = node.computedStyle || {};

  for (const prop of INHERITED_PROPERTIES) {
    // 명시적으로 지정되지 않았으면 부모에서 상속
    if (!nodeStyle[prop] && parentStyle[prop]) {
      nodeStyle[prop] = parentStyle[prop];
    }
  }

  node.computedStyle = nodeStyle;
}
```

## Shorthand 속성 처리

### Margin/Padding 확장

```typescript
// packages/core/style/shorthand.ts
import { ComputedStyle } from "../layout/types";

export function expandShorthands(style: ComputedStyle): void {
  // margin shorthand 확장
  if (style.margin) {
    const values = parseBoxShorthand(style.margin);
    style.marginTop = values.top;
    style.marginRight = values.right;
    style.marginBottom = values.bottom;
    style.marginLeft = values.left;
    delete style.margin;
  }

  // padding shorthand 확장
  if (style.padding) {
    const values = parseBoxShorthand(style.padding);
    style.paddingTop = values.top;
    style.paddingRight = values.right;
    style.paddingBottom = values.bottom;
    style.paddingLeft = values.left;
    delete style.padding;
  }

  // border shorthand 확장: "2px solid #e1e4e8"
  if (style.border) {
    const borderParts = style.border.split(/\s+/);
    for (const part of borderParts) {
      if (part.match(/^\d+px$/)) {
        style.borderWidth = part;
      } else if (part.match(/^(solid|dashed|dotted)$/)) {
        style.borderStyle = part;
      } else if (part.match(/^#|^rgb|^rgba/)) {
        style.borderColor = part;
      }
    }
    delete style.border;
  }

  // 기본값 설정
  const hasMargin =
    style.marginTop !== undefined ||
    style.marginRight !== undefined ||
    style.marginBottom !== undefined ||
    style.marginLeft !== undefined;
  if (hasMargin) {
    style.marginTop = style.marginTop || "0";
    style.marginRight = style.marginRight || "0";
    style.marginBottom = style.marginBottom || "0";
    style.marginLeft = style.marginLeft || "0";
  }

  const hasPadding =
    style.paddingTop !== undefined ||
    style.paddingRight !== undefined ||
    style.paddingBottom !== undefined ||
    style.paddingLeft !== undefined;
  if (hasPadding) {
    style.paddingTop = style.paddingTop || "0";
    style.paddingRight = style.paddingRight || "0";
    style.paddingBottom = style.paddingBottom || "0";
    style.paddingLeft = style.paddingLeft || "0";
  }

  const hasBorder =
    style.borderWidth !== undefined ||
    style.borderStyle !== undefined ||
    style.borderColor !== undefined;
  if (hasBorder) {
    style.borderWidth = style.borderWidth || "0";
    style.borderStyle = style.borderStyle || "solid";
    style.borderColor = style.borderColor || "#000";
  }

  const hasFont =
    style.fontSize !== undefined || style.fontWeight !== undefined;
  if (hasFont) {
    style.fontSize = style.fontSize || "16px";
    style.fontWeight = style.fontWeight || "normal";
  }
}

/**
 * Box shorthand를 4방향 값으로 파싱
 * - 1개 값: 모두 동일
 * - 2개 값: top/bottom, left/right
 * - 3개 값: top, left/right, bottom
 * - 4개 값: top, right, bottom, left
 */
function parseBoxShorthand(value: string): {
  top: string;
  right: string;
  bottom: string;
  left: string;
} {
  const parts = value.trim().split(/\s+/);

  switch (parts.length) {
    case 1:
      return {
        top: parts[0],
        right: parts[0],
        bottom: parts[0],
        left: parts[0],
      };
    case 2:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[0],
        left: parts[1],
      };
    case 3:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[1],
      };
    case 4:
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[3],
      };
    default:
      return { top: "0", right: "0", bottom: "0", left: "0" };
  }
}
```

## 리소스 로더

### HTML/CSS 파일 로드

```typescript
// packages/core/utils/loadResources.ts
export async function loadHTML(url: string): Promise<string> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load HTML: ${response.statusText}`);
  }
  return await response.text();
}

export async function loadCSS(url: string): Promise<string> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load CSS: ${response.statusText}`);
  }
  return await response.text();
}

export async function loadResources(htmlUrl: string, cssUrl: string) {
  const [htmlText, cssText] = await Promise.all([
    loadHTML(htmlUrl),
    loadCSS(cssUrl),
  ]);
  return { htmlText, cssText };
}
```

## 통합 렌더 함수

```typescript
// packages/core/render.ts
import { parseHTML } from "./html/parser";
import { parseCSS } from "./css/parser";
import { applyStyles } from "./style/resolver";
import { layout } from "./layout/engine";
import { paint } from "./paint/painter";
import { loadResources } from "./utils/loadResources";
import { LayoutBox } from "./layout/types";
import { DOMNode } from "./html/parser";

export interface RenderOptions {
  htmlUrl: string;
  cssUrl: string;
  ctx: CanvasRenderingContext2D;
  viewport: {
    width: number;
    height: number;
  };
}

export interface RenderResult {
  dom: DOMNode;
  layoutTree: LayoutBox;
}

export async function renderPage(
  options: RenderOptions
): Promise<RenderResult> {
  const { htmlUrl, cssUrl, ctx, viewport } = options;
  // 1. 리소스 로드
  console.time("Load Resources");
  const { htmlText, cssText } = await loadResources(htmlUrl, cssUrl);
  console.timeEnd("Load Resources");

  // 2. 파싱
  console.time("Parse HTML");
  const dom = parseHTML(htmlText);
  console.timeEnd("Parse HTML");

  console.time("Parse CSS");
  const cssRules = parseCSS(cssText);
  console.timeEnd("Parse CSS");

  // 3. 스타일 적용
  console.time("Apply Styles");
  applyStyles(dom, cssRules);
  console.timeEnd("Apply Styles");

  // 4. 레이아웃 계산
  console.time("Layout");
  const layoutTree = layout(dom, viewport, ctx);
  console.timeEnd("Layout");

  // 5. 페인팅
  console.time("Paint");
  const pixelRatio = window.devicePixelRatio || 1;
  paint(layoutTree, { ctx, pixelRatio });
  console.timeEnd("Paint");

  console.log("---- Render complete! ----");

  return { dom, layoutTree };
}
```

## 실전 데모

### part3.html

```html
<!-- packages/apps/gui/part3.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Mini Browser Demo</title>
  </head>
  <body>
    <div id="main" class="container">
      <h1 class="title">Hello Mini Browser</h1>
      <p class="description">이것은 우리가 만든 미니 브라우저입니다!</p>
      <div class="note">CSS 스타일링이 완벽하게 작동합니다.</div>
      <div class="card">
        <h2>박스 모델 테스트</h2>
        <p>margin, padding, border가 모두 적용됩니다.</p>
      </div>
    </div>
  </body>
</html>
```

### part3.css

```css
/* packages/apps/gui/part3.css */
body {
  background: #fff;
  font-size: 16px;
  padding: 20px;
  margin: 0;
}

#main {
  background: #f6f8fa;
  border: 2px solid #f82d0e;
  padding: 20px;
  margin: 20px auto;
}

.title {
  font-size: 16px;
  font-weight: bold;
  color: #0e60b2;
  margin-bottom: 16px;
}

.description {
  font-size: 12px;
  color: #586069;
  margin-bottom: 20px;
}

.note {
  background: #fff3cd;
  border: 1px solid #ffeeba;
  padding: 12px;
  margin-bottom: 20px;
  color: #856404;
}

.card {
  background: #ffffff;
  border: 1px solid #e1e4e8;
  padding: 16px;
}

.card h2 {
  font-size: 20px;
  color: #0e60b2;
  margin-bottom: 8px;
}

.card p {
  font-size: 14px;
  color: #586069;
}
```

### part3.ts

```typescript
// packages/apps/gui/part3.ts
import { renderPage } from "../../core/render";

async function main() {
  const canvas = document.getElementById("screen") as HTMLCanvasElement;
  const ctx = canvas.getContext("2d")!;

  // Canvas의 CSS 크기
  const cssWidth = canvas.clientWidth || window.innerWidth;
  const cssHeight = canvas.clientHeight || window.innerHeight;

  // HiDPI 대응: 실제 해상도 설정
  const pixelRatio = window.devicePixelRatio || 1;
  canvas.width = cssWidth * pixelRatio;
  canvas.height = cssHeight * pixelRatio;

  await renderPage({
    htmlUrl: "/part3.html",
    cssUrl: "/part3.css",
    ctx,
    viewport: { width: cssWidth, height: cssHeight },
  });
}

main().catch(console.error);
```

packages/apps/gui/index.html 에서 script 태그를 수정해서 part3.ts 파일을 실행합니다.

```html
<!-- 다른 내용은 유지 -->
<script type="module" src="/part3.ts"></script>
```

```bash
yarn install
yarn dev
```

**실행 결과**: Canvas에 배경색, 테두리, 여백이 정확히 적용된 HTML이 그려집니다!

## 성능 측정

개발자 도구 콘솔에서 각 단계의 소요 시간을 확인할 수 있습니다:

```
Load Resources: 45.2ms
Parse HTML: 2.1ms
Parse CSS: 1.3ms
Apply Styles: 3.7ms
Layout: 8.9ms
Paint: 4.2ms
---- Render complete! ----
```

**인사이트**:

- 네트워크 로딩이 가장 오래 걸림 (캐싱 필요)
- 레이아웃 계산이 두 번째로 느림 (Reflow 최적화 필요)
- 파싱과 페인팅은 상대적으로 빠름

## 배운 것들

### 1. CSS Cascade 알고리즘

브라우저가 CSS를 적용하는 방식을 깊이 이해했습니다:

- 특이성 계산 (ID > Class > Tag)
- 선언 순서의 중요성
- 상속되는 속성과 안 되는 속성

### 2. Reflow의 비용

레이아웃 재계산이 왜 비싼 연산인지 체감:

- 모든 노드를 재귀적으로 순회
- 부모-자식 간 의존성
- 캐싱과 최적화의 필요성

### 3. 파이프라인 설계

각 단계를 모듈화하여 조합:

- 단일 책임 원칙 (SRP)
- 인터페이스 분리
- 의존성 주입

### 4. 비동기 리소스 로딩

`Promise.all`로 병렬 로딩:

- HTML과 CSS를 동시에 fetch
- 네트워크 지연 시간 단축

## 최적화 아이디어

### 1. 증분 레이아웃

```typescript
// 변경된 노드만 재계산
function incrementalLayout(changedNode: DOMNode) {
  // 1. 영향받는 부모 체인 찾기
  const affectedNodes = getAffectedParents(changedNode);

  // 2. 해당 서브트리만 레이아웃 재계산
  for (const node of affectedNodes) {
    layoutSubtree(node);
  }
}
```

### 2. 스타일 캐싱

```typescript
// 한 번 계산한 스타일을 캐싱
const styleCache = new Map<string, ComputedStyle>();

function getComputedStyle(node: DOMNode): ComputedStyle {
  const cacheKey = getNodeKey(node);
  if (styleCache.has(cacheKey)) {
    return styleCache.get(cacheKey)!;
  }

  const style = calculateStyle(node);
  styleCache.set(cacheKey, style);
  return style;
}
```

### 3. Dirty Flag 패턴

```typescript
interface LayoutBox {
  // ... 기존 필드
  needsLayout: boolean;
  needsPaint: boolean;
}

function markNeedsLayout(box: LayoutBox) {
  box.needsLayout = true;
  // 부모도 마킹
  if (box.parent) {
    markNeedsLayout(box.parent);
  }
}
```

## 참고 자료

- [CSS Cascade and Inheritance](https://www.w3.org/TR/css-cascade-3/)
- [CSS Specificity](https://developer.mozilla.org/ko/docs/Web/CSS/Specificity)
- [Rendering Performance](https://web.dev/rendering-performance/)
