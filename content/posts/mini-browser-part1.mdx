---
title: "나만의 웹 브라우저 만들기 (1부) - HTML/CSS 파서 구현"
date: 2025-11-01
description: "브라우저는 HTML 문자열을 어떻게 이해할까? 토크나이저와 파서를 직접 구현하며 DOM 트리 생성의 원리를 배웁니다."
tags: ["Browser", "TypeScript", "Parser", "DOM"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (1부) - HTML/CSS 파서 구현

> "브라우저는 `<div class="box">Hello</div>` 같은 텍스트를 어떻게 이해할까?"

## 시리즈 소개

이 시리즈에서는 브라우저 렌더링 엔진을 밑바닥부터 구현하며 브라우저가 웹페이지를 어떻게 그리는지, 그 과정을 직접 구현해보면서 이해하는 것이 목표입니다.

**전체 시리즈 구성**:

- **Part 1: HTML/CSS 파서 구현 (현재)**
- Part 2: 레이아웃 & 페인팅 엔진
- Part 3: 통합 렌더 파이프라인
- Part 4: JavaScript 실행 환경
- Part 5: Electron 데스크톱 앱

**기술 스택**: TypeScript, Canvas API, Vite

## 브라우저 렌더링 파이프라인 개요

브라우저가 웹페이지를 화면에 그리는 과정은 다음과 같습니다:

```
사용자 입력(URL)
  ↓
네트워크 요청 (HTTP)
  ↓
HTML 파싱 → DOM 트리
  ↓
CSS 파싱 → CSSOM
  ↓
스타일 계산 (Style Resolution)
  ↓
레이아웃 계산 (Layout/Reflow)
  ↓
페인팅 (Paint/Rasterization)
  ↓
컴포지팅 (Compositing)
```

오늘은 이 중에서 **HTML 파싱**과 **CSS 파싱** 단계를 구현합니다.

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "types": ["node", "vite/client"]
  },
  "module": "ESNext"
}
```

## HTML 토크나이저 구현

### 토크나이저의 역할

> 토크나이저(Tokenizer)는 브라우저가 HTML을 이해하는 첫 번째 단계입니다. 연속된 문자열을 의미 있는 단위(토큰)로 쪼개는 역할을 합니다.

**예시**: `<div class="box">Hello</div>`를 다음과 같이 분리합니다:

- **StartTag**: `<div class="box">` → 태그 시작
- **Text**: `Hello` → 내용
- **EndTag**: `</div>` → 태그 종료

### 토크나이저 구현

이제 실제로 HTML 문자열을 토큰으로 분리하는 코드를 작성해봅시다.

```typescript
//  packages/core/html/lexer.ts
interface Token {
  type: "StartTag" | "EndTag" | "Text" | "Comment" | "Doctype";
  name?: string;
  attrs?: Record<string, string>;
  value?: string;
}

export function tokenize(html: string): Token[] {
  const tokens: Token[] = [];
  let pos = 0;

  while (pos < html.length) {
    // 태그 시작 찾기
    if (html[pos] === "<") {
      // DOCTYPE 처리
      if (html.slice(pos, pos + 9).toLowerCase() === "<!doctype") {
        const match = html.slice(pos).match(/^<!doctype[^>]*>/i);
        if (match) {
          tokens.push({
            type: "Doctype",
            value: match[0],
          });
          pos += match[0].length;
          continue;
        }
      }

      // 주석 처리
      if (html.slice(pos, pos + 4) === "<!--") {
        const endComment = html.indexOf("-->", pos);
        if (endComment !== -1) {
          tokens.push({
            type: "Comment",
            value: html.slice(pos + 4, endComment),
          });
          pos = endComment + 3;
          continue;
        }
      }

      // 닫는 태그
      if (html[pos + 1] === "/") {
        const match = html.slice(pos).match(/^<\/(\w+)\s*>/);
        if (match) {
          tokens.push({
            type: "EndTag",
            name: match[1],
          });
          pos += match[0].length;
          continue;
        }
      }

      // 여는 태그 (self-closing 포함)
      const match = html.slice(pos).match(/^<(\w+)([^>]*?)(\/?)>/);
      if (match) {
        const tagName = match[1];
        const attrString = match[2];
        const isSelfClosing = match[3] === "/";

        const attrs = parseAttributes(attrString);
        tokens.push({
          type: "StartTag",
          name: tagName,
          attrs,
        });

        // self-closing 태그는 바로 닫는 태그도 추가
        if (isSelfClosing) {
          tokens.push({
            type: "EndTag",
            name: tagName,
          });
        }

        pos += match[0].length;
        continue;
      }
    }

    // 텍스트 노드
    const textEnd = html.indexOf("<", pos);
    const text = html.slice(pos, textEnd === -1 ? undefined : textEnd).trim();
    if (text) {
      tokens.push({
        type: "Text",
        value: text,
      });
    }
    pos = textEnd === -1 ? html.length : textEnd;
  }

  return tokens;
}

function parseAttributes(attrString: string): Record<string, string> {
  const attrs: Record<string, string> = {};

  // 따옴표가 있는 속성: name="value" 또는 name='value'
  const quotedRegex = /(\w+[-:\w]*)=["']([^"']*)["']/g;
  let match;

  while ((match = quotedRegex.exec(attrString)) !== null) {
    attrs[match[1]] = match[2];
  }

  // 따옴표가 없는 속성: name=value
  const unquotedRegex = /(\w+[-:\w]*)=([^\s>"']+)/g;
  while ((match = unquotedRegex.exec(attrString)) !== null) {
    // 이미 처리된 속성은 건너뛰기
    if (!Object.prototype.hasOwnProperty.call(attrs, match[1])) {
      attrs[match[1]] = match[2];
    }
  }

  // 값이 없는 속성: disabled, checked 등
  const booleanRegex = /(\w+[-:\w]*)(?=\s|$)/g;
  while ((match = booleanRegex.exec(attrString)) !== null) {
    // 이미 처리된 속성이거나 = 다음에 오는 경우는 건너뛰기
    if (
      !Object.prototype.hasOwnProperty.call(attrs, match[1]) &&
      attrString[match.index + match[1].length] !== "="
    ) {
      attrs[match[1]] = "";
    }
  }

  return attrs;
}
```

### 동작 확인하기

토크나이저가 제대로 작동하는지 간단히 테스트해봅시다.

"packages/core/html/lexer.ts" 파일 하단에 다음 코드를 추가하고 `npx tsx packages/core/html/lexer`를 실행하세요:

```typescript
const tokens = tokenize('<div class="card">Hello</div>');
console.log(tokens);
// 출력:
// [
//   { type: 'StartTag', name: 'div', attrs: { class: 'card' } },
//   { type: 'Text', value: 'Hello' },
//   { type: 'EndTag', name: 'div' }
// ]
```

HTML 문자열이 의미 있는 토큰으로 분리된 것을 확인할 수 있습니다!

## HTML 파서 - DOM 트리 생성

### DOM 트리란?

> 이제 토큰을 트리 구조로 변환할 차례입니다. DOM(Document Object Model) 트리는 HTML 문서를 계층적 구조로 표현합니다.

예를 들어, `<div><h1>Title</h1><p>Text</p></div>`는 다음과 같은 트리가 됩니다:

```
div
├─ h1
│  └─ "Title"
└─ p
   └─ "Text"
```

### 스택 기반 파싱 알고리즘

> 중첩된 태그를 처리하기 위해 스택 자료구조를 활용합니다:

1. **StartTag** 만나면 → 새 노드를 생성하고 스택에 push
2. **EndTag** 만나면 → 스택에서 pop (해당 태그 종료)
3. **Text** 만나면 → 현재 부모(스택 최상단)에 텍스트 노드 추가

### 파서 구현

```typescript
// import { ComputedStyle } from "../layout/types";
import { tokenize } from "./lexer";

export interface DOMNode {
  id?: number; // 가시화용 내부 id
  type: "element" | "text";
  name?: string;
  attrs?: Record<string, string>;
  children?: DOMNode[];
  text?: string;
  parent?: DOMNode;
  //   computedStyle?: ComputedStyle; // 이 부분은 나중에 구현할 예정 (Part 2에서 구현, css 파싱 후 적용)
}

export function parseHTML(html: string): DOMNode {
  const tokens = tokenize(html);
  let nodeIdCounter = 1;

  const root: DOMNode = {
    type: "element",
    name: "root",
    children: [],
    id: nodeIdCounter++,
  };

  const stack: DOMNode[] = [root];

  for (const token of tokens) {
    const current = stack[stack.length - 1];

    if (token.type === "StartTag") {
      const node: DOMNode = {
        type: "element",
        name: token.name,
        attrs: token.attrs || {},
        children: [],
        parent: current,
        id: nodeIdCounter++,
      };
      current.children!.push(node);

      // 자식을 가질 수 있는 태그는 스택에 추가
      if (!isSelfClosing(token.name!)) {
        stack.push(node);
      }
    } else if (token.type === "EndTag") {
      // 스택에서 제거
      if (stack.length > 1) {
        stack.pop();
      }
    } else if (token.type === "Text") {
      current.children!.push({
        type: "text",
        text: token.value,
        parent: current,
        id: nodeIdCounter++,
      });
    }
    // DOCTYPE와 Comment는 무시 (렌더링에 영향 없음)
  }

  return root;
}

function isSelfClosing(tagName: string): boolean {
  return ["img", "br", "hr", "input", "meta", "link"].includes(tagName);
}
```

### 동작 확인하기

"packages/core/html/parser.ts" 파일 하단에 다음 코드를 추가하고 `npx tsx packages/core/html/parser`를 실행하세요.

```typescript
const dom = parseHTML('<div class="card">Hello</div>');
console.log(dom);
// 출력:
// {
//   type: 'element',
//   name: 'root',
//   children: [
//     {
//       type: 'element',
//       name: 'div',
//       attrs: [Object],
//       children: [Array],
//       parent: [Circular *1],
//       id: 2
//     }
//   ],
//   id: 1
// }
```

HTML이 계층적인 트리 구조로 변환되었습니다.

## CSS 파서 - CSSOM 생성

> HTML과 마찬가지로, CSS도 파싱이 필요합니다. CSS를 파싱하여 CSSOM(CSS Object Model)을 만들어봅시다.

### CSS 토크나이저 구현

CSS 문자열을 의미 있는 토큰으로 분리하는 것이 첫 단계입니다.

**예시**: 다음 CSS를 토큰으로 분리합니다:

```css
#main .card {
  background: #f6f8fa;
}
```

**토큰 타입**:

- **Selector**: `#main`, `.card`
- **Declaration**: 속성-값 쌍 (`background: #f6f8fa`)
- **구조 토큰**: `{`, `}`, `:`, `;`

### 토크나이저 구현

```typescript
/**
 * CSS 토큰 타입
 */
export type CSSTokenType =
  | "COMMENT"
  | "WHITESPACE"
  | "SELECTOR"
  | "LBRACE"
  | "RBRACE"
  | "PROPERTY"
  | "COLON"
  | "VALUE"
  | "SEMICOLON"
  | "COMMA"
  | "AT_RULE"
  | "EOF";

/**
 * CSS 토큰
 */
export interface CSSToken {
  type: CSSTokenType;
  value: string;
  line: number;
  column: number;
}

/**
 * CSS 문자열을 토큰으로 분리합니다.
 */
export function tokenizeCSS(css: string): CSSToken[] {
  const tokens: CSSToken[] = [];
  let pos = 0;
  let line = 1;
  let column = 1;

  while (pos < css.length) {
    const startLine = line;
    const startColumn = column;

    // 주석 /* ... */
    if (css[pos] === "/" && css[pos + 1] === "*") {
      const start = pos;
      pos += 2;
      column += 2;

      while (pos < css.length && !(css[pos] === "*" && css[pos + 1] === "/")) {
        if (css[pos] === "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        pos++;
      }

      if (pos < css.length) {
        pos += 2; // */ 건너뛰기
        column += 2;
      }

      tokens.push({
        type: "COMMENT",
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
      continue;
    }

    // 공백 (스페이스, 탭, 개행)
    if (/\s/.test(css[pos])) {
      const start = pos;
      while (pos < css.length && /\s/.test(css[pos])) {
        if (css[pos] === "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        pos++;
      }

      tokens.push({
        type: "WHITESPACE",
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
      continue;
    }

    // 단일 문자 토큰
    if (css[pos] === "{") {
      tokens.push({ type: "LBRACE", value: "{", line, column });
      pos++;
      column++;
      continue;
    }

    if (css[pos] === "}") {
      tokens.push({ type: "RBRACE", value: "}", line, column });
      pos++;
      column++;
      continue;
    }

    if (css[pos] === ":") {
      tokens.push({ type: "COLON", value: ":", line, column });
      pos++;
      column++;
      continue;
    }

    if (css[pos] === ";") {
      tokens.push({ type: "SEMICOLON", value: ";", line, column });
      pos++;
      column++;
      continue;
    }

    if (css[pos] === ",") {
      tokens.push({ type: "COMMA", value: ",", line, column });
      pos++;
      column++;
      continue;
    }

    // @ 규칙 (@media, @keyframes, @import 등)
    if (css[pos] === "@") {
      const start = pos;
      pos++;
      column++;

      // at-rule 이름 읽기
      while (pos < css.length && /[a-zA-Z0-9-_]/.test(css[pos])) {
        pos++;
        column++;
      }

      tokens.push({
        type: "AT_RULE",
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
      continue;
    }

    // 선택자 또는 속성/값 (컨텍스트에 따라 구분)
    // 여기서는 일단 SELECTOR로 읽고, parser에서 컨텍스트에 따라 해석
    const start = pos;

    // 문자열 따옴표 처리
    if (css[pos] === '"' || css[pos] === "'") {
      const quote = css[pos];
      pos++;
      column++;

      while (pos < css.length && css[pos] !== quote) {
        if (css[pos] === "\\") {
          pos++; // 이스케이프 문자 건너뛰기
          column++;
        }
        if (css[pos] === "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        pos++;
      }

      if (pos < css.length) {
        pos++; // 닫는 따옴표
        column++;
      }

      tokens.push({
        type: "VALUE",
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
      continue;
    }

    // 괄호 안의 값 (예: url(...), rgb(...))
    if (css[pos] === "(") {
      let parenCount = 1;
      pos++;
      column++;

      while (pos < css.length && parenCount > 0) {
        if (css[pos] === "(") parenCount++;
        if (css[pos] === ")") parenCount--;
        if (css[pos] === "\n") {
          line++;
          column = 1;
        } else {
          column++;
        }
        pos++;
      }

      tokens.push({
        type: "VALUE",
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
      continue;
    }

    // 일반 식별자/값 (공백, 특수문자 전까지)
    while (pos < css.length && !/[\s{};:,()/]/.test(css[pos])) {
      pos++;
      column++;
    }

    if (pos > start) {
      tokens.push({
        type: "SELECTOR", // parser에서 컨텍스트에 따라 PROPERTY/VALUE로 해석
        value: css.slice(start, pos),
        line: startLine,
        column: startColumn,
      });
    }
  }

  tokens.push({ type: "EOF", value: "", line, column });

  return tokens;
}

/**
 * 공백과 주석을 제외한 토큰만 반환합니다.
 */
export function filterTokens(tokens: CSSToken[]): CSSToken[] {
  return tokens.filter(
    (token) => token.type !== "WHITESPACE" && token.type !== "COMMENT"
  );
}
```

### 동작 확인하기

"packages/core/css/lexer.ts" 파일 하단에 다음 코드를 추가하고 `npx tsx packages/core/css/lexer`를 실행하세요.

```typescript
const tokens = tokenizeCSS(
  "/* comment */ #main .card { background: #f6f8fa; border: 2px solid #e1e4e8; padding: 16px; }"
);
console.log(tokens);
// 출력:
// [
//   { type: 'COMMENT', value: '/* comment */', line: 1, column: 1 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 14 },
//   { type: 'SELECTOR', value: '#main', line: 1, column: 15 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 20 },
//   { type: 'SELECTOR', value: '.card', line: 1, column: 21 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 26 },
//   { type: 'LBRACE', value: '{', line: 1, column: 27 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 28 },
//   { type: 'SELECTOR', value: 'background', line: 1, column: 29 },
//   { type: 'COLON', value: ':', line: 1, column: 39 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 40 },
//   { type: 'SELECTOR', value: '#f6f8fa', line: 1, column: 41 },
//   { type: 'SEMICOLON', value: ';', line: 1, column: 48 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 49 },
//   { type: 'SELECTOR', value: 'border', line: 1, column: 50 },
//   { type: 'COLON', value: ':', line: 1, column: 56 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 57 },
//   { type: 'SELECTOR', value: '2px', line: 1, column: 58 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 61 },
//   { type: 'SELECTOR', value: 'solid', line: 1, column: 62 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 67 },
//   { type: 'SELECTOR', value: '#e1e4e8', line: 1, column: 68 },
//   { type: 'SEMICOLON', value: ';', line: 1, column: 75 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 76 },
//   { type: 'SELECTOR', value: 'padding', line: 1, column: 77 },
//   { type: 'COLON', value: ':', line: 1, column: 84 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 85 },
//   { type: 'SELECTOR', value: '16px', line: 1, column: 86 },
//   { type: 'SEMICOLON', value: ';', line: 1, column: 90 },
//   { type: 'WHITESPACE', value: ' ', line: 1, column: 91 },
//   { type: 'RBRACE', value: '}', line: 1, column: 92 },
//   { type: 'EOF', value: '', line: 1, column: 93 }
// ]
```

## CSS 파서 구현

### CSS 파서의 역할

> 토큰을 구조화된 CSS 규칙(Rule)으로 변환합니다. 각 규칙은 "어떤 요소에" (선택자), "어떤 스타일을" (선언부) 적용할지 정의합니다.

**예시**: 다음 CSS를 구조화합니다:

```css
#main .card {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
}
```

**결과 구조**:

- **Selectors**: `["#main .card"]` → 어떤 요소에?
- **Declarations**: `{ background: "#f6f8fa", border: "2px solid #e1e4e8", ... }` → 어떤 스타일을?

### 파서 구현

```typescript
//  packages/core/css/parser.ts

import { tokenizeCSS, filterTokens, CSSToken } from "./lexer";

export interface CSSRule {
  selectors: string[];
  declarations: Record<string, string>;
}

/**
 * CSS 문자열을 파싱하여 규칙 목록을 반환합니다.
 */
export function parseCSS(css: string): CSSRule[] {
  const allTokens = tokenizeCSS(css);
  const tokens = filterTokens(allTokens);

  return parseRules(tokens);
}

/**
 * 토큰 목록에서 CSS 규칙을 파싱합니다.
 */
function parseRules(tokens: CSSToken[]): CSSRule[] {
  const rules: CSSRule[] = [];
  let pos = 0;

  while (pos < tokens.length && tokens[pos].type !== "EOF") {
    // @ 규칙은 현재 무시 (추후 확장 가능)
    if (tokens[pos].type === "AT_RULE") {
      pos = skipAtRule(tokens, pos);
      continue;
    }

    // 선택자 수집 (LBRACE 전까지)
    const selectorTokens: string[] = [];
    while (
      pos < tokens.length &&
      tokens[pos].type !== "LBRACE" &&
      tokens[pos].type !== "EOF"
    ) {
      if (tokens[pos].type === "COMMA") {
        // 쉼표는 선택자 구분자
        pos++;
        continue;
      }
      selectorTokens.push(tokens[pos].value);
      pos++;
    }

    if (tokens[pos]?.type !== "LBRACE") break;
    pos++; // '{' 건너뛰기

    // 선택자 파싱 (공백으로 연결된 선택자들을 쉼표로 분리)
    const selectorsText = selectorTokens.join(" ");
    const selectors = selectorsText
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s && !s.includes("import") && !s.includes("from"));

    if (selectors.length === 0) {
      // 빈 선택자면 RBRACE까지 건너뛰기
      while (pos < tokens.length && tokens[pos].type !== "RBRACE") {
        pos++;
      }
      if (tokens[pos]?.type === "RBRACE") pos++;
      continue;
    }

    // 선언부 파싱 (RBRACE 전까지)
    const declarations = parseDeclarations(tokens, pos);
    pos = declarations.nextPos;

    if (Object.keys(declarations.props).length > 0) {
      rules.push({ selectors, declarations: declarations.props });
    }

    // '}' 건너뛰기
    if (tokens[pos]?.type === "RBRACE") {
      pos++;
    }
  }

  return rules;
}

/**
 * 선언부를 파싱합니다.
 */
function parseDeclarations(
  tokens: CSSToken[],
  startPos: number
): { props: Record<string, string>; nextPos: number } {
  const props: Record<string, string> = {};
  let pos = startPos;

  while (
    pos < tokens.length &&
    tokens[pos].type !== "RBRACE" &&
    tokens[pos].type !== "EOF"
  ) {
    // 속성명 읽기
    if (tokens[pos].type !== "SELECTOR") {
      pos++;
      continue;
    }

    const property = kebabToCamelCase(tokens[pos].value);
    pos++;

    // ':' 건너뛰기
    if (tokens[pos]?.type !== "COLON") continue;
    pos++;

    // 값 수집 (';' 또는 '}' 전까지)
    const valueTokens: string[] = [];
    while (
      pos < tokens.length &&
      tokens[pos].type !== "SEMICOLON" &&
      tokens[pos].type !== "RBRACE" &&
      tokens[pos].type !== "EOF"
    ) {
      valueTokens.push(tokens[pos].value);
      pos++;
    }

    const value = valueTokens.join(" ").trim();
    if (property && value) {
      props[property] = value;
    }

    // ';' 건너뛰기
    if (tokens[pos]?.type === "SEMICOLON") {
      pos++;
    }
  }

  return { props, nextPos: pos };
}

/**
 * @ 규칙을 건너뜁니다. (중첩된 블록 포함)
 */
function skipAtRule(tokens: CSSToken[], startPos: number): number {
  let pos = startPos + 1; // '@rule' 건너뛰기
  let braceCount = 0;

  while (pos < tokens.length && tokens[pos].type !== "EOF") {
    if (tokens[pos].type === "LBRACE") {
      braceCount++;
    } else if (tokens[pos].type === "RBRACE") {
      braceCount--;
      if (braceCount <= 0) {
        pos++;
        break;
      }
    } else if (tokens[pos].type === "SEMICOLON" && braceCount === 0) {
      // 블록 없는 @ 규칙 (예: @import)
      pos++;
      break;
    }
    pos++;
  }

  return pos;
}

/**
 * kebab-case를 camelCase로 변환
 * 예: "font-size" -> "fontSize", "margin-top" -> "marginTop"
 */
function kebabToCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}
```

## CLI로 파싱 결과 확인

이제 만든 파서를 테스트해봅시다.

```typescript
//  packages/apps/cli/day1.ts

import { parseHTML } from "../../core/html/parser";
import { parseCSS } from "../../core/css/parser";

const html = `
<html>
  <body>
    <div id="main" class="card">
      <h1>Hello Mini Browser</h1>
      <p>This is a test.</p>
    </div>
  </body>
</html>
`;

const css = `
#main {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
}

h1 {
  font-size: 24px;
  color: #24292e;
}
`;

const dom = parseHTML(html);
const cssRules = parseCSS(css);

// 순환 참조를 피하기 위해 parent 속성을 제외하고 출력
const replacer = (key: string, value: unknown) => {
  if (key === "parent") {
    return undefined;
  }
  return value;
};

console.log("DOM Tree:", JSON.stringify(dom, replacer, 2));
console.log("\nCSS Rules:", JSON.stringify(cssRules, replacer, 2));
```

**실행**:

```bash
npx tsx packages/apps/cli/day1.ts
```

## 배운 것들

이번 편에서 배운 핵심 개념:

### 파싱의 기본 원리

- **Lexical Analysis**: 문자열을 토큰으로 분해
- **Syntax Analysis**: 토큰을 트리 구조로 조합

## 참고 자료

- [HTML Spec - Parsing](https://html.spec.whatwg.org/multipage/parsing.html)
- [CSS Syntax Module](https://www.w3.org/TR/css-syntax-3/)
- [How Browsers Work](https://web.dev/howbrowserswork/)
