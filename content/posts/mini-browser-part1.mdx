---
title: "나만의 웹 브라우저 만들기 (1부) - HTML/CSS 파서 구현"
date: 2025-11-01
description: "브라우저는 HTML 문자열을 어떻게 이해할까? 토크나이저와 파서를 직접 구현하며 DOM 트리 생성의 원리를 배웁니다."
tags: ["Browser", "TypeScript", "Parser", "DOM"]
category: "개발"
---

# 나만의 웹 브라우저 만들기 (1부) - HTML/CSS 파서 구현

> "브라우저는 `<div class="box">Hello</div>` 같은 텍스트를 어떻게 이해할까?"

## 시리즈 소개

이 시리즈에서는 브라우저 렌더링 엔진을 밑바닥부터 구현하며 웹 기술의 진짜 원리를 배웁니다. Chrome이나 Firefox가 웹페이지를 어떻게 그리는지, 그 과정을 직접 구현해보면서 체득하는 것이 목표입니다.

**전체 시리즈 구성**:

- **Part 1: HTML/CSS 파서 구현 (현재)**
- Part 2: 레이아웃 & 페인팅 엔진
- Part 3: 통합 렌더 파이프라인
- Part 4: JavaScript 실행 환경
- Part 5: Electron 데스크톱 앱

**기술 스택**: TypeScript, Canvas API, Vite

## 브라우저 렌더링 파이프라인 개요

브라우저가 웹페이지를 화면에 그리는 과정은 다음과 같습니다:

```
사용자 입력(URL)
  ↓
네트워크 요청 (HTTP)
  ↓
HTML 파싱 → DOM 트리
  ↓
CSS 파싱 → CSSOM
  ↓
스타일 계산 (Style Resolution)
  ↓
레이아웃 계산 (Layout/Reflow)
  ↓
페인팅 (Paint/Rasterization)
  ↓
컴포지팅 (Compositing)
```

오늘은 이 중에서 **HTML 파싱**과 **CSS 파싱** 단계를 구현합니다.

## HTML 토크나이저 구현

### 토크나이저란?

토크나이저(Tokenizer)는 문자열을 의미 있는 단위로 쪼개는 역할을 합니다. HTML 문자열을 태그, 속성, 텍스트 등의 토큰으로 분리합니다.

**토큰 타입**:

- **StartTag**: `<div class="box">`
- **EndTag**: `</div>`
- **Text**: `Hello World`
- **Attribute**: `class="box"`

### 구현 코드

```typescript
// packages/core/html/lexer.ts
interface Token {
  type: "StartTag" | "EndTag" | "Text" | "Comment" | "Doctype";
  name?: string;
  attrs?: Record<string, string>;
  value?: string;
}

export function tokenize(html: string): Token[] {
  const tokens: Token[] = [];
  let pos = 0;

  while (pos < html.length) {
    // 태그 시작 찾기
    if (html[pos] === "<") {
      // DOCTYPE 처리
      if (html.slice(pos, pos + 9).toLowerCase() === "<!doctype") {
        const match = html.slice(pos).match(/^<!doctype[^>]*>/i);
        if (match) {
          tokens.push({
            type: "Doctype",
            value: match[0],
          });
          pos += match[0].length;
          continue;
        }
      }

      // 주석 처리
      if (html.slice(pos, pos + 4) === "<!--") {
        const endComment = html.indexOf("-->", pos);
        if (endComment !== -1) {
          tokens.push({
            type: "Comment",
            value: html.slice(pos + 4, endComment),
          });
          pos = endComment + 3;
          continue;
        }
      }

      // 닫는 태그
      if (html[pos + 1] === "/") {
        const match = html.slice(pos).match(/^<\/(\w+)\s*>/);
        if (match) {
          tokens.push({
            type: "EndTag",
            name: match[1],
          });
          pos += match[0].length;
          continue;
        }
      }

      // 여는 태그 (self-closing 포함)
      const match = html.slice(pos).match(/^<(\w+)([^>]*?)(\/?)>/);
      if (match) {
        const tagName = match[1];
        const attrString = match[2];
        const isSelfClosing = match[3] === "/";

        const attrs = parseAttributes(attrString);
        tokens.push({
          type: "StartTag",
          name: tagName,
          attrs,
        });

        // self-closing 태그는 바로 닫는 태그도 추가
        if (isSelfClosing) {
          tokens.push({
            type: "EndTag",
            name: tagName,
          });
        }

        pos += match[0].length;
        continue;
      }
    }

    // 텍스트 노드
    const textEnd = html.indexOf("<", pos);
    const text = html.slice(pos, textEnd === -1 ? undefined : textEnd).trim();
    if (text) {
      tokens.push({
        type: "Text",
        value: text,
      });
    }
    pos = textEnd === -1 ? html.length : textEnd;
  }

  return tokens;
}

function parseAttributes(attrString: string): Record<string, string> {
  const attrs: Record<string, string> = {};

  // 따옴표가 있는 속성: name="value" 또는 name='value'
  const quotedRegex = /(\w+[-:\w]*)=["']([^"']*)["']/g;
  let match;

  while ((match = quotedRegex.exec(attrString)) !== null) {
    attrs[match[1]] = match[2];
  }

  // 따옴표가 없는 속성: name=value
  const unquotedRegex = /(\w+[-:\w]*)=([^\s>"']+)/g;
  while ((match = unquotedRegex.exec(attrString)) !== null) {
    // 이미 처리된 속성은 건너뛰기
    if (!attrs.hasOwnProperty(match[1])) {
      attrs[match[1]] = match[2];
    }
  }

  // 값이 없는 속성: disabled, checked 등
  const booleanRegex = /(\w+[-:\w]*)(?=\s|$)/g;
  while ((match = booleanRegex.exec(attrString)) !== null) {
    // 이미 처리된 속성이거나 = 다음에 오는 경우는 건너뛰기
    if (
      !attrs.hasOwnProperty(match[1]) &&
      attrString[match.index + match[1].length] !== "="
    ) {
      attrs[match[1]] = "";
    }
  }

  return attrs;
}
```

**사용 예시**:

"packages/core/html/lexer.ts" 파일 안에 맨 하단에 아래 코드를 넣고 "npx tsx packages/core/html/lexer" 를 실행하면 확인 할 수 있습니다.

```typescript
const tokens = tokenize('<div class="card">Hello</div>');
console.log(tokens);
// 출력:
// [
//   { type: 'StartTag', name: 'div', attrs: { class: 'card' } },
//   { type: 'Text', value: 'Hello' },
//   { type: 'EndTag', name: 'div' }
// ]
```

## HTML 파서 - DOM 트리 생성

### DOM 트리란?

DOM(Document Object Model) 트리는 HTML 문서를 계층적 구조로 표현한 것입니다. 각 태그와 텍스트가 노드가 되어 부모-자식 관계를 형성합니다.

### 스택 기반 파싱

HTML 파서는 스택을 사용하여 중첩된 태그를 처리합니다:

- **StartTag** 만나면 → 스택에 push
- **EndTag** 만나면 → 스택에서 pop
- **Text** 만나면 → 현재 부모에 추가

### 구현 코드

```typescript
// packages/core/html/parser.ts
import { tokenize } from "./lexer";
// import { ComputedStyle } from "../layout/types"; // 이 부분은 나중에 구현할 예정 (Part 2에서 구현, css 파싱 후 적용)

export interface DOMNode {
  id?: number; // 가시화용 내부 id
  type: "element" | "text";
  name?: string;
  attrs?: Record<string, string>;
  children?: DOMNode[];
  text?: string;
  parent?: DOMNode;
  // computedStyle?: ComputedStyle; // 이 부분은 나중에 구현할 예정 (Part 2에서 구현, css 파싱 후 적용)
}

export function parseHTML(html: string): DOMNode {
  const tokens = tokenize(html);
  let nodeIdCounter = 1;

  const root: DOMNode = {
    type: "element",
    name: "root",
    children: [],
    id: nodeIdCounter++,
  };

  const stack: DOMNode[] = [root];

  for (const token of tokens) {
    const current = stack[stack.length - 1];

    if (token.type === "StartTag") {
      const node: DOMNode = {
        type: "element",
        name: token.name,
        attrs: token.attrs || {},
        children: [],
        parent: current,
        id: nodeIdCounter++,
      };
      current.children!.push(node);

      // 자식을 가질 수 있는 태그는 스택에 추가
      if (!isSelfClosing(token.name!)) {
        stack.push(node);
      }
    } else if (token.type === "EndTag") {
      // 스택에서 제거
      if (stack.length > 1) {
        stack.pop();
      }
    } else if (token.type === "Text") {
      current.children!.push({
        type: "text",
        text: token.value,
        parent: current,
        id: nodeIdCounter++,
      });
    }
    // DOCTYPE와 Comment는 무시 (렌더링에 영향 없음)
  }

  return root;
}

function isSelfClosing(tagName: string): boolean {
  return ["img", "br", "hr", "input", "meta", "link"].includes(tagName);
}
```

**DOM 트리 구조**:

```typescript
{
  type: 'element',
  name: 'div',
  attrs: { class: 'card' },
  children: [
    {
      type: 'text',
      text: 'Hello'
      id: 2
    }
  ]
}
```

## CSS 파서 구현

### CSS 구조 이해

CSS는 선택자와 속성-값 쌍으로 구성됩니다:

```css
#main .card {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
}
```

이것을 다음과 같은 구조로 파싱합니다:

```typescript
{
  selectors: ['#main .card'],
  declarations: {
    'background': '#f6f8fa',
    'border': '2px solid #e1e4e8',
    'padding': '16px'
  }
}
```

### 구현 코드

```typescript
// packages/core/css/parser.ts
export interface CSSRule {
  selectors: string[];
  declarations: Record<string, string>;
}

export function parseCSS(css: string): CSSRule[] {
  const rules: CSSRule[] = [];

  // 주석 제거
  css = css.replace(/\/\*[\s\S]*?\*\//g, "");

  // 공백 정규화 (개행, 탭 등을 모두 단일 공백으로)
  css = css.replace(/[\r\n\t\f\v]+/g, " ");
  css = css.replace(/\s\s+/g, " ");
  css = css.trim();

  // 룰셋을 하나씩 파싱
  let pos = 0;
  while (pos < css.length) {
    // 공백 건너뛰기
    while (pos < css.length && css[pos] === " ") {
      pos++;
    }

    if (pos >= css.length) break;

    // 선택자 찾기 ('{' 이전까지)
    const selectorStart = pos;
    while (pos < css.length && css[pos] !== "{") {
      pos++;
    }

    if (pos >= css.length) break;

    const selectorsText = css.slice(selectorStart, pos).trim();
    pos++; // '{' 건너뛰기

    // 선언부 찾기 ('}' 이전까지)
    const declStart = pos;
    let braceCount = 1;
    while (pos < css.length && braceCount > 0) {
      if (css[pos] === "{") braceCount++;
      if (css[pos] === "}") braceCount--;
      if (braceCount > 0) pos++;
    }

    const declarationsText = css.slice(declStart, pos).trim();
    pos++; // '}' 건너뛰기

    // 선택자 파싱 (쉼표로 구분)
    const selectors = selectorsText
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s && !s.includes("import") && !s.includes("from"));

    if (selectors.length === 0) continue;

    // 속성 파싱
    const declarations: Record<string, string> = {};
    const declParts = declarationsText.split(";").filter((s) => s.trim());

    for (const part of declParts) {
      const colonIndex = part.indexOf(":");
      if (colonIndex === -1) continue;

      const property = kebabToCamelCase(part.slice(0, colonIndex).trim());
      const value = part.slice(colonIndex + 1).trim();

      if (property && value) {
        declarations[property] = value;
      }
    }

    // 선언이 있는 경우만 추가
    if (Object.keys(declarations).length > 0) {
      rules.push({ selectors, declarations });
    }
  }

  return rules;
}

/**
 * kebab-case를 camelCase로 변환
 * 예: "font-size" -> "fontSize", "margin-top" -> "marginTop"
 */
function kebabToCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}
```

### 선택자 타입 구분

```typescript
export function parseSelector(selector: string): {
  type: "id" | "class" | "tag" | "descendant";
  value: string;
} {
  selector = selector.trim();

  if (selector.startsWith("#")) {
    return { type: "id", value: selector.slice(1) };
  }
  if (selector.startsWith(".")) {
    return { type: "class", value: selector.slice(1) };
  }
  if (selector.includes(" ")) {
    return { type: "descendant", value: selector };
  }
  return { type: "tag", value: selector };
}
```

## CLI로 파싱 결과 확인

이제 만든 파서를 테스트해봅시다.

```typescript
// packages/apps/cli/day1.ts

import { parseHTML } from "../../core/html/parser";
import { parseCSS } from "../../core/css/parser";

const html = `
<html>
  <body>
    <div id="main" class="card">
      <h1>Hello Mini Browser</h1>
      <p>This is a test.</p>
    </div>
  </body>
</html>
`;

const css = `
#main {
  background: #f6f8fa;
  border: 2px solid #e1e4e8;
  padding: 16px;
}

h1 {
  font-size: 24px;
  color: #24292e;
}
`;

const dom = parseHTML(html);
const cssRules = parseCSS(css);

// 순환 참조를 피하기 위해 parent 속성을 제외하고 출력
const replacer = (key: string, value: any) => {
  if (key === "parent") {
    return undefined;
  }
  return value;
};

console.log("DOM Tree:", JSON.stringify(dom, replacer, 2));
console.log("\nCSS Rules:", JSON.stringify(cssRules, null, 2));
```

**실행**:

```bash
npx tsx packages/apps/cli/day1.ts
```

## 배운 것들

이번 편에서 배운 핵심 개념:

### 파싱의 기본 원리

- **Lexical Analysis**: 문자열을 토큰으로 분해
- **Syntax Analysis**: 토큰을 트리 구조로 조합

## 다음 편 예고

DOM 트리는 만들었지만, 이걸 어떻게 화면에 그릴까요?

**Part 2**에서는:

- CSS 박스 모델 계산
- 레이아웃 엔진 구현
- Canvas API로 실제 렌더링

## 참고 자료

- [HTML Spec - Parsing](https://html.spec.whatwg.org/multipage/parsing.html)
- [CSS Syntax Module](https://www.w3.org/TR/css-syntax-3/)
- [How Browsers Work](https://web.dev/howbrowserswork/)
