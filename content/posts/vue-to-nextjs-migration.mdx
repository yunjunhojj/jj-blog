---
title: Vue에서 Next.js로 단계적 마이그레이션하기
date: 2025-01-28
description: iframe과 postMessage를 활용해 Vue.js 프로젝트를 Next.js로 점진적으로 전환하는 실전 전략을 알아봅니다.
tags: [Vue, Next.js, Migration, iframe, postMessage]
category: 개발
---

Vue.js로 완성된 서비스를 Next.js로 옮길 때, **한 번에 갈아엎지 않고 점진적으로 교체**하는 방법을 정리합니다. iframe을 활용해 공존 기간을 확보하고, `postMessage`로 양방향 통신을 붙이는 전략을 다룹니다.

⸻

## 1. 왜 Next.js로 마이그레이션할까?

### 1) SSR/SSG 기본 제공

Vue도 Nuxt.js로 SSR이 가능하지만, Next.js는 React 생태계를 기반으로 더 다양한 커뮤니티와 빠른 업데이트를 제공합니다.

### 2) React 중심의 조직 표준화

조직 내 React 스택을 사용하는 프로젝트가 늘어나면서, Vue와 React를 혼용하기보다는 통일된 기술 스택으로 효율적인 개발을 기대할 수 있습니다.

채용 관점에서도 React 개발자가 더 많아 인력 수급이 용이합니다.

### 3) 성능과 SEO 최적화

Next.js는 SSR과 SSG를 간단하게 지원하며, 라우팅·이미지 최적화·번들 스플리팅 등 내장 기능으로 운영 복잡도를 줄일 수 있습니다.

⸻

## 2. 마이그레이션 전략: iframe을 이용한 단계적 교체

### 왜 iframe인가?

레거시 Vue 프로젝트를 완전히 새로 만들기엔 리스크가 크거나, 특정 기능만 우선 React로 옮겨야 하는 경우가 있습니다.

이런 상황에서 **iframe을 통해 Next.js로 구현한 화면을 Vue 서비스 내부에 삽입**해, 원하는 시점에 점진적으로 대체할 수 있습니다.

### iframe 구성 방식

**1. Vue 메인 앱 (레거시)**

- 기존 Vue 앱이 전체 레이아웃이나 공통 UI, 인증 로직 등을 담당합니다.

**2. Next.js 서브 앱 (신규)**

- 신규 기능을 React와 Next.js로 구현하여 iframe으로 불러옵니다.
- 독립된 도메인 또는 서브도메인을 사용합니다.

**3. 통신 (modal 관리, toast, 로딩바 등)**

- Vue 메인 앱 ↔ Next.js 서브 앱 간 데이터나 이벤트를 주고받을 때 `postMessage`를 사용합니다.

⸻

## 3. postMessage로 통신하는 방법

### postMessage의 특징

- `postMessage`는 서로 다른 도메인 간에도 메시지를 주고받을 수 있도록 지원합니다.
- `window.postMessage(message, targetOrigin)` API를 통해 메시지를 전송하고, `window.addEventListener('message', handler)`를 사용해 이벤트를 수신합니다.
- **보안을 위해 `targetOrigin`을 정확히 지정**하거나, 유효성 검증을 거치도록 합니다.

### 메시지 타입 정의 (공통 유틸로 분리 권장)

```typescript
// shared/messages.ts
export type Message =
  | { type: "FROM_VUE"; data: string }
  | { type: "FROM_NEXT"; data: string }
  | { type: "TODO_CREATED"; data: { id: number; title: string } }
  | { type: "TODO_DELETED"; data: { id: number } };

export const isMessage = (v: unknown): v is Message => {
  if (typeof v !== "object" || v === null || !("type" in v)) return false;
  const type = (v as any).type;
  return ["FROM_VUE", "FROM_NEXT", "TODO_CREATED", "TODO_DELETED"].includes(
    type
  );
};
```

### Vue 메인 앱에서 Next.js 서브 앱으로 메시지 전송

```
<template>
  <div>
    <h2>Todo 생성 Iframe</h2>
    <iframe
      ref="nextFrame"
      src="http://localhost:8001/add-iframe"
      width="100%"
      height="600"
      @load="onIframeLoad"
    />
    <button @click="sendMessage">Next.js로 메시지 보내기</button>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from "vue";
import { isMessage } from "../shared/messages";

const nextOrigin = "http://localhost:8001";
const nextFrame = ref(null);

const sendMessage = () => {
  const message = { type: "FROM_VUE", data: "Hello Next.js!" };
  nextFrame.value?.contentWindow?.postMessage(message, nextOrigin);
};

const handleMessage = (event) => {
  // 출처 확인
  if (event.origin !== nextOrigin) return;

  // 메시지 타입 검증
  if (!isMessage(event.data)) return;

  if (event.data.type === "FROM_NEXT") {
    console.log("Next에서 보낸 데이터:", event.data.data);
  } else if (event.data.type === "TODO_CREATED") {
    console.log("새 Todo 생성됨:", event.data.data);
    // Vue 앱의 상태 업데이트 또는 이벤트 발행
  }
};

const onIframeLoad = () => {
  // 초기 핸드셰이크 메시지 전송 (필요 시)
  sendMessage();
};

onMounted(() => {
  window.addEventListener("message", handleMessage);
});

onBeforeUnmount(() => {
  window.removeEventListener("message", handleMessage);
});
</script>
```

### Next.js 서브 앱에서 Vue 메인 앱으로 메시지 수신 및 응답

```tsx
// pages/add-iframe.tsx
import { useEffect, useState } from "react";
import { isMessage } from "../shared/messages";

const vueOrigin = "http://localhost:8080";

export default function AddIframe() {
  const [newTodo, setNewTodo] = useState("");

  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      // 출처 확인
      if (event.origin !== vueOrigin) return;

      // 메시지 타입 검증
      if (!isMessage(event.data)) return;

      if (event.data.type === "FROM_VUE") {
        console.log("Vue에서 보낸 데이터:", event.data.data);

        // 메시지 응답
        event.source?.postMessage(
          { type: "FROM_NEXT", data: "Hello Vue!" },
          { targetOrigin: event.origin }
        );
      }
    };

    window.addEventListener("message", handleMessage);

    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, []);

  const addTodo = async () => {
    if (!newTodo.trim()) return;

    try {
      const response = await fetch("http://localhost:3000/todos", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title: newTodo }),
      });

      if (response.ok) {
        const createdTodo = await response.json();

        // Vue 앱에 생성 이벤트 알림
        window.parent.postMessage(
          { type: "TODO_CREATED", data: createdTodo },
          vueOrigin
        );

        setNewTodo("");
      }
    } catch (error) {
      console.error("할 일 추가 실패", error);
    }
  };

  return (
    <div>
      <h1>Next.js Todo 생성</h1>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
        placeholder="할 일 입력"
        onKeyUp={(e) => e.key === "Enter" && addTodo()}
      />
      <button onClick={addTodo}>추가</button>
    </div>
  );
}
```

⸻

## 4. 구현 시 주의사항

### 1) 보안 이슈

- `postMessage`를 사용할 때 **출처를 반드시 확인**해야 합니다.
- `targetOrigin`을 정확히 지정하거나, 출처 검증을 통해 보안 취약점을 방지합니다.
- 메시지 스키마를 정의하고 런타임 타입 가드를 적용하면 안전합니다.

### 2) 성능 고려

- iframe은 독립적인 문서로 구동되므로, 불필요한 네트워크 요청이나 리소스 낭비가 생길 수 있습니다.
- 필요한 경우에만 iframe을 사용하고, 점차 전체 페이지로 전환하는 로드맵을 계획합니다.
- 로딩 UX: iframe `onload` 이벤트로 스피너 표시, 타임아웃/에러 메시지 처리를 추가합니다.

### 3) 반복되는 코드 최소화

- 데이터를 주고받는 로직은 공통 모듈로 분리해 중복을 최소화합니다.
- 메시지 타입과 핸들러를 유틸 함수로 추상화합니다.

### 4) SEO 및 SSR 제한

- iframe에 렌더링된 콘텐츠는 부모 페이지가 SSR을 하더라도 검색 엔진이 직접 인덱싱하기 어렵습니다.
- 마이그레이션이 끝나면 iframe 의존도를 줄이는 방향을 갖습니다.

### 5) 접근성 (Accessibility)

- iframe에 명확한 `title` 속성을 부여합니다.
- 포커스 트랩과 키보드 내비게이션을 확인합니다.
- 스크린 리더 사용자를 위한 ARIA 레이블을 추가합니다.

### 6) 환경 변수 관리

```bash
# .env.development (Vue)
VITE_NEXT_ORIGIN=http://localhost:8001
VITE_API_URL=http://localhost:3000

# .env.development (Next.js)
NEXT_PUBLIC_VUE_ORIGIN=http://localhost:8080
NEXT_PUBLIC_API_URL=http://localhost:3000
```

⸻

## 5. 실습: Todo 앱 마이그레이션 예시

### 프로젝트 구조

```
root/
├─ vue-app/                 # Vue 메인 앱
│  ├─ src/
│  │  ├─ views/
│  │  │  ├─ TodoAll.vue
│  │  │  ├─ TodoListIframe.vue
│  │  │  └─ AddIframe.vue
│  │  ├─ shared/
│  │  │  └─ messages.ts
│  │  └─ App.vue
│  ├─ db.json
│  └─ package.json
└─ next-app/                # Next.js 서브 앱
   ├─ pages/
   │  ├─ todo-list.tsx
   │  ├─ add-iframe.tsx
   │  └─ index.tsx
   ├─ shared/
   │  └─ messages.ts
   └─ package.json
```

### 프로젝트 생성 및 설정

```bash
# 프로젝트 폴더 생성
mkdir vue-next-migration
cd vue-next-migration

# Vue 프로젝트 생성
yarn create vite vue-app --template vue-ts

# Next.js 프로젝트 생성
yarn create next-app next-app --typescript

# dev port 설정
# vue-app: 8080 (기본값)
# next-app: 8001 (package.json의 dev 스크립트를 "next dev -p 8001"로 수정)
```

### JSON Server 설치 및 설정

```bash
# vue-app 폴더에서
cd vue-app
yarn add -D json-server
```

`db.json` 파일 생성:

```json
{
  "todos": [{ "id": 1, "title": "Sample Todo" }]
}
```

`package.json` 스크립트 추가:

```json
"scripts": {
  "dev": "vite",
  "json-server": "json-server --watch db.json --port 3000"
}
```

실행:

```bash
# 터미널 1
yarn dev

# 터미널 2
yarn json-server
```

### Vue 메인 앱 구현

**App.vue**

```
<template>
  <div class="layout">
    <nav>
      <ul>
        <li><a href="#/todoAll">Todo All (Vue)</a></li>
        <li><a href="#/todoListIframe">Todo List (Next.js)</a></li>
        <li><a href="#/addIframe">Todo 생성 (Next.js)</a></li>
      </ul>
    </nav>
    <component :is="currentView" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from "vue";
import TodoAll from "./views/TodoAll.vue";
import TodoListIframe from "./views/TodoListIframe.vue";
import AddIframe from "./views/AddIframe.vue";
import NotFound from "./views/NotFound.vue";

const routes: Record<string, any> = {
  "/": TodoAll,
  "/todoAll": TodoAll,
  "/todoListIframe": TodoListIframe,
  "/addIframe": AddIframe,
};

const currentPath = ref(window.location.hash || "#/");

window.addEventListener("hashchange", () => {
  currentPath.value = window.location.hash || "#/";
});

const currentView = computed(() => {
  const path = currentPath.value.slice(1) || "/";
  return routes[path] ?? NotFound;
});
</script>

<style scoped>
nav ul {
  list-style: none;
  display: flex;
  gap: 1rem;
  padding: 1rem;
  background: #f0f0f0;
}

nav a {
  text-decoration: none;
  color: #333;
  font-weight: 500;
}

nav a:hover {
  color: #0070f3;
}
</style>
```

**views/TodoAll.vue**

```
<template>
  <div class="todo-container">
    <h2>Todo 생성 및 목록 (Vue + JSON Server)</h2>
    <div class="input-group">
      <input
        v-model="newTodo"
        placeholder="할 일 입력"
        @keyup.enter="addTodo"
      />
      <button @click="addTodo">추가</button>
    </div>

    <ul class="todo-list">
      <li v-for="todo in todos" :key="todo.id">
        {{ todo.title }}
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from "vue";

interface Todo {
  id: number;
  title: string;
}

const todos = ref<Todo[]>([]);
const newTodo = ref("");

const fetchTodos = async () => {
  try {
    const response = await fetch("http://localhost:3000/todos");
    todos.value = await response.json();
  } catch (error) {
    console.error("할 일 목록을 불러오는데 실패했습니다.", error);
  }
};

const addTodo = async () => {
  if (!newTodo.value.trim()) return;

  const newTask = { title: newTodo.value };

  try {
    const response = await fetch("http://localhost:3000/todos", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(newTask),
    });

    if (response.ok) {
      const createdTodo = await response.json();
      todos.value.push(createdTodo);
      newTodo.value = "";
    }
  } catch (error) {
    console.error("할 일 추가 실패", error);
  }
};

onMounted(fetchTodos);
</script>

<style scoped>
.todo-container {
  padding: 2rem;
}

.input-group {
  display: flex;
  gap: 0.5rem;
  margin: 1rem 0;
}

input {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

button {
  padding: 0.5rem 1rem;
  background: #0070f3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #0051cc;
}

.todo-list {
  list-style: none;
  padding: 0;
}

.todo-list li {
  padding: 0.75rem;
  border-bottom: 1px solid #eee;
}
</style>
```

**views/AddIframe.vue** (위의 예시 참고)

**views/NotFound.vue**

```
<template>
  <div class="not-found">
    <h2>404 - 페이지를 찾을 수 없습니다</h2>
  </div>
</template>

<style scoped>
.not-found {
  padding: 2rem;
  text-align: center;
}
</style>
```

### Next.js 서브 앱 구현

**pages/todo-list.tsx**

```tsx
import { useEffect, useState } from "react";

interface Todo {
  id: number;
  title: string;
}

export default function TodoList() {
  const [todos, setTodos] = useState<Todo[]>([]);

  useEffect(() => {
    fetch("http://localhost:3000/todos")
      .then((res) => res.json())
      .then((data) => setTodos(data))
      .catch((err) => console.error("목록 로딩 실패", err));
  }, []);

  return (
    <div style={{ padding: "2rem" }}>
      <h1>Next.js Todo 목록</h1>
      <ul style={{ listStyle: "none", padding: 0 }}>
        {todos.map((todo) => (
          <li
            key={todo.id}
            style={{
              padding: "0.75rem",
              borderBottom: "1px solid #eee",
            }}
          >
            {todo.title}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

⸻

## 6. 보안·성능·운영 팁

### CSP와 Sandbox

필요 시 iframe에 `sandbox` 속성을 추가하고, `Content-Security-Policy` 헤더로 출처를 제한합니다.

```html
<iframe
  src="http://localhost:8001/add-iframe"
  sandbox="allow-scripts allow-same-origin"
  title="Todo 생성"
/>
```

### 상태 동기화 전략

- `postMessage`는 이벤트 전달용으로 한정하고, 실제 데이터는 공유 백엔드(REST/GraphQL)를 통해 동기화합니다.
- 낙관적 업데이트(Optimistic Update)와 함께 사용하면 UX가 개선됩니다.

### 성능 측정

- Lighthouse, Web Vitals로 성능 지표를 측정합니다.
- Next.js의 이미지 최적화(`next/image`), 번들 스플리팅, lazy-loading을 적극 활용합니다.

### 배포 전략

- Vercel/Netlify 등 서버리스 플랫폼 활용.
- CloudFront + S3로 정적 배포 시, 환경변수는 `.env.production`으로 분리합니다.
- CI/CD 파이프라인(GitHub Actions, GitLab CI)으로 자동화합니다.

⸻

## 7. 마이그레이션 로드맵 제안

### 1단계: 공존 (Coexistence)

- Vue 메인 + Next iframe (핵심 신규 화면부터 이동)
- 공통 API 서버를 통해 데이터 동기화
- postMessage로 최소한의 이벤트만 전달

### 2단계: 점진 확대 (Gradual Expansion)

- 공통 UI/디자인 시스템을 Next 기준으로 재사용
- iframe 비중 축소, 라우팅 단위로 전환

### 3단계: 전환 (Transition)

- Next를 루트 앱으로, Vue 부분을 iframe 혹은 마이크로프런트엔드로 최소화
- 인증/권한 로직을 Next로 이관

### 4단계: 정리 (Consolidation)

- 라우팅/상태/빌드 파이프라인을 Next 기준으로 단일화
- SEO/모니터링 최적화
- Vue 레거시 코드 완전 제거

⸻

## 8. 마무리

iframe + postMessage는 **위험을 나눠서** 옮길 수 있는 실용적인 방법입니다.

다만 출처 검증, 성능/SEO 한계를 명확히 이해하고, **최종적으로는 Next.js 단일 스택으로 수렴**하는 로드맵을 병행해야 합니다.

마이그레이션은 단순히 기술 스택을 바꾸는 것이 아니라, **팀의 개발 문화와 협업 방식을 개선하는 기회**입니다.

체계적인 계획과 점진적 실행으로 안전하게 전환해 나가시길 바랍니다.
