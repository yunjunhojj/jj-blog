---
title: 프론트엔드에서 서버와 통신하는 모든 방식 정리
date: 2025-01-20
description: HTTP · Polling · Long Polling · WebSocket · SSE · GraphQL까지 프론트엔드 개발자가 알아야 할 모든 서버 통신 방식을 정리하고, React + Node 실습 프로젝트 코드를 제공합니다.
tags: [Frontend, React, WebSocket, SSE, HTTP, TypeScript, Node.js]
category: 개발
---

프론트엔드 개발을 하다 보면 "서버와 데이터를 어떻게 주고받을까?"라는 질문을 반복해서 만나게 됩니다.

특히 React 기반 애플리케이션을 개발하면서 **실시간 통신이 필요한 순간**이 오면 HTTP 요청만으로는 부족해지고, Polling · WebSocket · SSE 같은 다양한 선택지가 등장합니다.

이 글에서는 프론트엔드 관점에서 **서버와 통신하는 모든 방법**을 한 번에 정리하고, 실습 가능한 **React + Node 테스트 프로젝트** 전체 구조와 코드까지 제공합니다.

## 개요: 서버 통신 방식은 크게 두 축으로 나뉜다

통신 방식들은 두 가지 기준에서 분류할 수 있습니다.

### 1) 단방향 vs 양방향

- **단방향:** 클라이언트 → 서버 중심 (HTTP, Polling, SSE)
- **양방향:** 클라이언트 ↔ 서버 양쪽 모두 자유롭게 메시지 전송 (WebSocket)

### 2) 요청 기반 vs 푸시 기반

- **요청 기반:** 클라이언트가 요청할 때만 응답 (HTTP, Polling, Long Polling)
- **푸시 기반:** 서버가 알아서 클라이언트에 푸시 (WebSocket, SSE, GraphQL Subscription)

---

## 1. HTTP (REST / GraphQL Query/Mutation)

HTTP는 가장 기본적인 통신 방식으로, 대부분의 CRUD 요청은 HTTP로 해결됩니다.

### 언제 사용하면 좋은가?

- 서버에 요청 한번 보내고 끝나는 작업
- 로그인, 데이터 조회, 생성/수정/삭제
- 실시간성이 필요 없는 경우

### React 예제 (fetch)

```typescript
const res = await fetch("/api/todos");
const data = await res.json();
```

### React 예제 (axios)

```typescript
import axios from "axios";

const fetchTodos = async () => {
  const { data } = await axios.get("/api/todos");
  return data;
};
```

---

## 2. Polling (주기적으로 HTTP 요청)

정해진 간격마다 서버에 계속 요청을 보내는 방식입니다.

### 언제 사용하면 좋은가?

- 3~5초 단위의 "준실시간"이면 충분할 때
- 대시보드 숫자 업데이트
- 비동기 작업 상태 모니터링

### React 예제

```typescript
import { useEffect, useState } from "react";

function DashboardStats() {
  const [stats, setStats] = useState({ userCount: 0, orderCount: 0 });

  useEffect(() => {
    const fetchStats = async () => {
      const res = await fetch("/api/stats");
      const data = await res.json();
      setStats(data);
    };

    fetchStats(); // 즉시 실행
    const id = setInterval(fetchStats, 5000); // 5초마다 실행

    return () => clearInterval(id);
  }, []);

  return (
    <div>
      <p>사용자 수: {stats.userCount}</p>
      <p>주문 수: {stats.orderCount}</p>
    </div>
  );
}
```

### 장점

- 구현이 간단함
- HTTP만으로 해결 가능
- 브라우저 호환성이 좋음

### 단점

- 불필요한 요청이 많아짐
- 서버 부하 증가
- 실시간성이 떨어짐

---

## 3. Long Polling

Polling의 개선된 형태로, 서버가 새 데이터가 생길 때까지 요청을 유지했다가 응답을 반환합니다.

### 언제 사용하면 좋은가?

- WebSocket 사용이 어려운 환경
- 채팅, 알림 스트림 등 실시간성이 필요한 경우
- 방화벽이나 프록시 환경에서 WebSocket이 차단된 경우

### 동작 원리

1. 클라이언트가 서버에 요청을 보냄
2. 서버는 새 데이터가 있을 때까지 응답을 보류
3. 새 데이터가 생기면 즉시 응답
4. 클라이언트는 응답을 받으면 즉시 새로운 요청을 보냄

### React 예제

```typescript
import { useEffect, useState } from "react";

function LongPollingChat() {
  const [messages, setMessages] = useState<string[]>([]);
  const [lastId, setLastId] = useState("0");

  useEffect(() => {
    const poll = async () => {
      try {
        const res = await fetch(`/api/chat/long-poll?lastId=${lastId}`);
        const { messages: newMessages } = await res.json();

        if (newMessages.length > 0) {
          setMessages((prev) => [...prev, ...newMessages]);
          setLastId(newMessages[newMessages.length - 1].id);
        }
      } catch (error) {
        console.error("Long polling error:", error);
      } finally {
        // 응답을 받으면 즉시 다시 요청
        poll();
      }
    };

    poll();
  }, [lastId]);

  return (
    <div>
      {messages.map((msg, idx) => (
        <div key={idx}>{msg.text}</div>
      ))}
    </div>
  );
}
```

### 장점

- HTTP만으로 실시간 통신 구현 가능
- WebSocket보다 간단한 설정
- 방화벽 우회 가능

### 단점

- 연결이 자주 끊어짐
- 서버에서 연결을 유지해야 해서 리소스 사용
- 타임아웃 처리 필요

---

## 4. WebSocket (양방향 실시간 통신)

지속적인 연결을 유지하며 서버 ↔ 클라이언트 양방향 메시지 사용이 가능합니다.

### 언제 사용하면 좋은가?

- 채팅 애플리케이션
- 주식 시세, 실시간 대시보드
- 게임 상태 동기화
- 협업 도구 (Google Docs 같은 실시간 편집)

### React 예제

```typescript
import { useEffect, useState, useRef } from "react";

function WebSocketChat() {
  const [messages, setMessages] = useState<string[]>([]);
  const [input, setInput] = useState("");
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    const ws = new WebSocket("ws://localhost:4000");
    wsRef.current = ws;

    ws.onopen = () => {
      console.log("WebSocket 연결됨");
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setMessages((prev) => [...prev, data.message]);
    };

    ws.onerror = (error) => {
      console.error("WebSocket 에러:", error);
    };

    ws.onclose = () => {
      console.log("WebSocket 연결 종료");
    };

    return () => {
      ws.close();
    };
  }, []);

  const sendMessage = () => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(input);
      setInput("");
    }
  };

  return (
    <div>
      <div>
        {messages.map((msg, idx) => (
          <div key={idx}>{msg}</div>
        ))}
      </div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === "Enter" && sendMessage()}
      />
      <button onClick={sendMessage}>전송</button>
    </div>
  );
}
```

### 장점

- 낮은 지연시간
- 양방향 통신
- 효율적인 리소스 사용 (연결 유지)

### 단점

- 서버 구현이 복잡함
- 연결 관리 필요 (재연결 로직)
- 일부 프록시/방화벽에서 차단될 수 있음

---

## 5. Server-Sent Events (SSE)

서버 → 클라이언트 단방향 스트림입니다. 브라우저의 EventSource 객체로 간단하게 사용 가능합니다.

### 언제 사용하면 좋은가?

- 알림 스트림
- 단방향 로그 스트림
- 주기적 푸시가 필요한 실시간 데이터
- 서버에서 클라이언트로만 데이터를 보내는 경우

### React 예제

```typescript
import { useEffect, useState } from "react";

function NotificationStream() {
  const [notifications, setNotifications] = useState<string[]>([]);

  useEffect(() => {
    const eventSource = new EventSource("/api/notifications/stream");

    eventSource.onmessage = (event) => {
      setNotifications((prev) => [...prev, event.data]);
    };

    eventSource.onerror = (error) => {
      console.error("SSE 에러:", error);
      eventSource.close();
    };

    return () => {
      eventSource.close();
    };
  }, []);

  return (
    <div>
      <h2>알림 스트림</h2>
      {notifications.map((notif, idx) => (
        <div key={idx}>{notif}</div>
      ))}
    </div>
  );
}
```

### 장점

- HTTP 기반이라 설정이 간단함
- 자동 재연결 지원
- WebSocket보다 가벼움

### 단점

- 단방향 통신만 가능 (서버 → 클라이언트)
- 일부 브라우저에서 제한적 지원
- 텍스트 데이터만 전송 가능

---

## 6. GraphQL Subscriptions

GraphQL 환경에서 실시간 이벤트를 받고 싶을 때 사용합니다. 내부 구현은 WebSocket 또는 SSE 기반입니다.

### 언제 사용하면 좋은가?

- GraphQL을 사용하는 프로젝트
- 실시간 데이터 업데이트가 필요한 경우
- 타입 안전한 실시간 통신이 필요한 경우

### React 예제 (Apollo Client)

```typescript
import { useSubscription } from "@apollo/client";
import { gql } from "@apollo/client";

const MESSAGE_SUBSCRIPTION = gql`
  subscription OnMessageAdded {
    messageAdded {
      id
      text
      timestamp
    }
  }
`;

function GraphQLChat() {
  const { data, loading } = useSubscription(MESSAGE_SUBSCRIPTION);

  if (loading) return <div>로딩 중...</div>;

  return <div>{data?.messageAdded && <div>{data.messageAdded.text}</div>}</div>;
}
```

---

## 실습 프로젝트: React + Node 서버 전체 구성

이제 위 통신 방식들을 모두 직접 확인할 수 있는 간단한 React & Node 실습 환경을 구성해보겠습니다.

### 프로젝트 구조

```
project-root
├── server
│   ├── package.json
│   └── index.js
└── frontend
    ├── package.json
    ├── vite.config.ts
    └── src
        ├── main.tsx
        ├── App.tsx
        ├── api.ts
        └── features
            ├── http/TodoList.tsx
            ├── polling/DashboardStats.tsx
            ├── longPolling/LongPollingChat.tsx
            ├── websocket/WebSocketChat.tsx
            └── sse/NotificationStream.tsx
```

### Node 서버 코드 전체 (Express + WebSocket + SSE)

아래 서버는 다음 기능을 모두 포함합니다:

- REST API 예제
- Polling용 Stats API
- Long Polling
- SSE 스트림
- WebSocket 채팅 서버

```javascript
import express from "express";
import cors from "cors";
import http from "http";
import { WebSocketServer } from "ws";

const app = express();
app.use(cors());
app.use(express.json());

const server = http.createServer(app);
const wss = new WebSocketServer({ server });

const PORT = 4000;

/** 1. HTTP (REST) */
const todos = [
  { id: 1, title: "첫 번째 할일", completed: false },
  { id: 2, title: "두 번째 할일", completed: true },
];

app.get("/api/todos", (_, res) => res.json(todos));

/** 2. Polling Stats */
let userCount = 10;
let orderCount = 3;

setInterval(() => {
  userCount += 1;
  orderCount += 1;
}, 5000);

app.get("/api/stats", (_, res) => res.json({ userCount, orderCount }));

/** 3. Long Polling */
let messages = [{ id: "1", text: "안녕하세요!" }];
let longPollingClients = [];

app.get("/api/chat/long-poll", (req, res) => {
  const lastId = req.query.lastId;
  const newMessages = lastId
    ? messages.filter((m) => Number(m.id) > Number(lastId))
    : messages;

  if (newMessages.length > 0) return res.json({ messages: newMessages });

  const client = { res };
  longPollingClients.push(client);

  setTimeout(() => {
    longPollingClients = longPollingClients.filter((c) => c !== client);
    res.json({ messages: [] });
  }, 30000);
});

app.post("/api/chat/message", (req, res) => {
  const id = String(messages.length + 1);
  const message = { id, text: req.body.text };
  messages.push(message);

  longPollingClients.forEach((c) => c.res.json({ messages: [message] }));
  longPollingClients = [];

  res.json(message);
});

/** 4. SSE */
let sseClients = [];

app.get("/api/notifications/stream", (req, res) => {
  res.writeHead(200, {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
  });

  const clientId = Date.now();
  sseClients.push({ id: clientId, res });
  res.write(`data: 연결됨\n\n`);

  req.on("close", () => {
    sseClients = sseClients.filter((c) => c.id !== clientId);
  });
});

setInterval(() => {
  const msg = `서버 시각: ${new Date().toISOString()}`;
  sseClients.forEach((c) => c.res.write(`data: ${msg}\n\n`));
}, 5000);

/** 5. WebSocket */
wss.on("connection", (ws) => {
  ws.send(JSON.stringify({ type: "system", message: "환영합니다!" }));

  ws.on("message", (data) => {
    wss.clients.forEach((client) => {
      if (client.readyState === 1) {
        client.send(
          JSON.stringify({
            type: "chat",
            message: data.toString(),
            timestamp: Date.now(),
          })
        );
      }
    });
  });
});

server.listen(PORT, () =>
  console.log(`Server running on http://localhost:${PORT}`)
);
```

### React (Vite + TypeScript) UI 구성

React에서는 탭을 만들어 각 통신 방식을 하나씩 확인할 수 있게 구성했습니다.

#### App.tsx

```typescript
import { useState } from "react";
import TodoList from "./features/http/TodoList";
import DashboardStats from "./features/polling/DashboardStats";
import LongPollingChat from "./features/longPolling/LongPollingChat";
import WebSocketChat from "./features/websocket/WebSocketChat";
import NotificationStream from "./features/sse/NotificationStream";

function App() {
  const [tab, setTab] = useState("http");

  return (
    <div>
      <nav>
        <button onClick={() => setTab("http")}>HTTP</button>
        <button onClick={() => setTab("polling")}>Polling</button>
        <button onClick={() => setTab("longPolling")}>Long Polling</button>
        <button onClick={() => setTab("websocket")}>WebSocket</button>
        <button onClick={() => setTab("sse")}>SSE</button>
      </nav>

      <main>
        {tab === "http" && <TodoList />}
        {tab === "polling" && <DashboardStats />}
        {tab === "longPolling" && <LongPollingChat />}
        {tab === "websocket" && <WebSocketChat />}
        {tab === "sse" && <NotificationStream />}
      </main>
    </div>
  );
}

export default App;
```

탭을 변경하면서 HTTP / Polling / Long Polling / WebSocket / SSE 동작을 모두 확인할 수 있습니다.

### 실행 방법

**서버 실행**

```bash
cd server
yarn install
yarn start
```

**프론트 실행**

```bash
cd frontend
yarn install
yarn dev
```

`http://localhost:5173` 접속하여 확인 가능합니다.

---

## 통신 방식 비교표

| 방식                 | 방향   | 실시간성  | 구현 난이도 | 서버 부하 | 사용 사례           |
| -------------------- | ------ | --------- | ----------- | --------- | ------------------- |
| HTTP                 | 단방향 | 낮음      | 쉬움        | 낮음      | CRUD 작업           |
| Polling              | 단방향 | 중간      | 쉬움        | 높음      | 대시보드            |
| Long Polling         | 단방향 | 높음      | 중간        | 중간      | 채팅, 알림          |
| WebSocket            | 양방향 | 매우 높음 | 어려움      | 낮음      | 실시간 채팅, 게임   |
| SSE                  | 단방향 | 높음      | 쉬움        | 낮음      | 알림 스트림         |
| GraphQL Subscription | 양방향 | 매우 높음 | 어려움      | 낮음      | GraphQL 기반 실시간 |

## 마무리

이 글에서는 프론트엔드에서 서버와 통신하는 방식들을 기초부터 실시간 기법까지 모두 정리했습니다.

- **단발성 작업** → HTTP
- **몇 초 단위 갱신** → Polling
- **WebSocket이 어려울 때** → Long Polling
- **고성능 실시간 양방향** → WebSocket
- **단방향 실시간 스트림** → SSE
- **GraphQL 기반 실시간** → Subscriptions

또한 실제 실습 가능한 React + Node 서버 전체 프로젝트 코드를 제공해, 각 기술을 직접 테스트하며 체감할 수 있게 구성했습니다.
